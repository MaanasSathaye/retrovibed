//go:build !genieql.ignore
// +build !genieql.ignore

package library

import (
	"context"
	"database/sql"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/retrovibed/retrovibed/internal/sqlx"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql auto -v -o genieql.gen.go
// invoked by go generate @ library/10_generate.genieql.go line 3

// Metadata generated by genieql
type Metadata struct {
	ArchiveID       string    `json:"archive_id"`
	AutoDescription string    `json:"auto_description"`
	Bytes           uint64    `json:"bytes"`
	CreatedAt       time.Time `json:"created_at"`
	Description     string    `json:"description"`
	HiddenAt        time.Time `json:"hidden_at"`
	ID              string    `json:"id"`
	Image           string    `json:"image"`
	Mimetype        string    `json:"mimetype"`
	TombstonedAt    time.Time `json:"tombstoned_at"`
	TorrentID       string    `json:"torrent_id"`
	UpdatedAt       time.Time `json:"updated_at"`
}

// MetadataScanner scanner interface.
type MetadataScanner interface {
	Scan(i *Metadata) error
	Next() bool
	Close() error
	Err() error
}

type errMetadataScanner struct {
	e error
}

func (t errMetadataScanner) Scan(i *Metadata) error {
	return t.e
}

func (t errMetadataScanner) Next() bool {
	return false
}

func (t errMetadataScanner) Err() error {
	return t.e
}

func (t errMetadataScanner) Close() error {
	return nil
}

// MetadataScannerStaticColumns generated by genieql
const MetadataScannerStaticColumns = `library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`

// NewMetadataScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewMetadataScannerStatic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerStatic{
		Rows: rows,
	}
}

// metadataScannerStatic generated by genieql
type metadataScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t metadataScannerStatic) Scan(i *Metadata) error {
	var (
		c0  sql.NullString
		c1  sql.NullString
		c2  sql.NullInt64
		c3  sql.NullTime
		c4  sql.NullString
		c5  sql.NullTime
		c6  sql.NullString
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullTime
		c10 sql.NullString
		c11 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11); err != nil {
		return err
	}

	if c0.Valid {
		if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
			return err
		} else {
			i.ArchiveID = uid.String()
		}
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		tmp := uint64(c2.Int64)
		i.Bytes = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.CreatedAt = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Description = tmp
	}

	if c5.Valid {
		tmp := c5.Time
		i.HiddenAt = tmp
	}

	if c6.Valid {
		if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.Image = tmp
	}

	if c8.Valid {
		tmp := string(c8.String)
		i.Mimetype = tmp
	}

	if c9.Valid {
		tmp := c9.Time
		i.TombstonedAt = tmp
	}

	if c10.Valid {
		if uid, err := uuid.FromBytes([]byte(c10.String)); err != nil {
			return err
		} else {
			i.TorrentID = uid.String()
		}
	}

	if c11.Valid {
		tmp := c11.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewMetadataScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewMetadataScannerStaticRow(row *sql.Row) MetadataScannerStaticRow {
	return MetadataScannerStaticRow{
		row: row,
	}
}

// MetadataScannerStaticRow generated by genieql
type MetadataScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t MetadataScannerStaticRow) Scan(i *Metadata) error {
	var (
		c0  sql.NullString
		c1  sql.NullString
		c2  sql.NullInt64
		c3  sql.NullTime
		c4  sql.NullString
		c5  sql.NullTime
		c6  sql.NullString
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullTime
		c10 sql.NullString
		c11 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11); err != nil {
		return err
	}

	if c0.Valid {
		if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
			return err
		} else {
			i.ArchiveID = uid.String()
		}
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		tmp := uint64(c2.Int64)
		i.Bytes = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.CreatedAt = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Description = tmp
	}

	if c5.Valid {
		tmp := c5.Time
		i.HiddenAt = tmp
	}

	if c6.Valid {
		if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.Image = tmp
	}

	if c8.Valid {
		tmp := string(c8.String)
		i.Mimetype = tmp
	}

	if c9.Valid {
		tmp := c9.Time
		i.TombstonedAt = tmp
	}

	if c10.Valid {
		if uid, err := uuid.FromBytes([]byte(c10.String)); err != nil {
			return err
		} else {
			i.TorrentID = uid.String()
		}
	}

	if c11.Valid {
		tmp := c11.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t MetadataScannerStaticRow) Err(err error) MetadataScannerStaticRow {
	t.err = err
	return t
}

// NewMetadataScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewMetadataScannerDynamic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerDynamic{
		Rows: rows,
	}
}

// metadataScannerDynamic generated by genieql
type metadataScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t metadataScannerDynamic) Scan(i *Metadata) error {
	const (
		cn0  = "archive_id"
		cn1  = "auto_description"
		cn2  = "bytes"
		cn3  = "created_at"
		cn4  = "description"
		cn5  = "hidden_at"
		cn6  = "id"
		cn7  = "image"
		cn8  = "mimetype"
		cn9  = "tombstoned_at"
		cn10 = "torrent_id"
		cn11 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullString
		c1      sql.NullString
		c2      sql.NullInt64
		c3      sql.NullTime
		c4      sql.NullString
		c5      sql.NullTime
		c6      sql.NullString
		c7      sql.NullString
		c8      sql.NullString
		c9      sql.NullTime
		c10     sql.NullString
		c11     sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		case cn8:
			dst = append(dst, &c8)
		case cn9:
			dst = append(dst, &c9)
		case cn10:
			dst = append(dst, &c10)
		case cn11:
			dst = append(dst, &c11)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
					return err
				} else {
					i.ArchiveID = uid.String()
				}
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.AutoDescription = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := uint64(c2.Int64)
				i.Bytes = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := c3.Time
				i.CreatedAt = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := string(c4.String)
				i.Description = tmp
			}

		case cn5:
			if c5.Valid {
				tmp := c5.Time
				i.HiddenAt = tmp
			}

		case cn6:
			if c6.Valid {
				if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn7:
			if c7.Valid {
				tmp := string(c7.String)
				i.Image = tmp
			}

		case cn8:
			if c8.Valid {
				tmp := string(c8.String)
				i.Mimetype = tmp
			}

		case cn9:
			if c9.Valid {
				tmp := c9.Time
				i.TombstonedAt = tmp
			}

		case cn10:
			if c10.Valid {
				if uid, err := uuid.FromBytes([]byte(c10.String)); err != nil {
					return err
				} else {
					i.TorrentID = uid.String()
				}
			}

		case cn11:
			if c11.Valid {
				tmp := c11.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// MetadataInsertWithDefaultsStaticColumns generated by genieql
const MetadataInsertWithDefaultsStaticColumns = `$1,$2,$3,DEFAULT,$4,DEFAULT,$5,$6,$7,DEFAULT,$8,DEFAULT`

// MetadataInsertWithDefaultsExplode generated by genieql
func MetadataInsertWithDefaultsExplode(a *Metadata) ([]interface{}, error) {
	var (
		c0 sql.NullString // archive_id
		c1 sql.NullString // auto_description
		c2 sql.NullInt64  // bytes
		c3 sql.NullString // description
		c4 sql.NullString // id
		c5 sql.NullString // image
		c6 sql.NullString // mimetype
		c7 sql.NullString // torrent_id
	)

	c0.Valid = true
	c0.String = a.ArchiveID

	c1.Valid = true
	c1.String = a.AutoDescription

	c2.Valid = true
	c2.Int64 = int64(a.Bytes)

	c3.Valid = true
	c3.String = a.Description

	c4.Valid = true
	c4.String = a.ID

	c5.Valid = true
	c5.String = a.Image

	c6.Valid = true
	c6.String = a.Mimetype

	c7.Valid = true
	c7.String = a.TorrentID

	return []interface{}{c0, c1, c2, c3, c4, c5, c6, c7}, nil
}

// MetadataInsertWithDefaults generated by genieql
func MetadataInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Metadata) MetadataScannerStaticRow {
	const query = `INSERT INTO "library_metadata" ("archive_id","auto_description","bytes","created_at","description","hidden_at","id","image","mimetype","tombstoned_at","torrent_id","updated_at") VALUES ($1,$2,$3,DEFAULT,$4,DEFAULT,$5,$6,$7,DEFAULT,$8,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT RETURNING "archive_id","auto_description","bytes","created_at","description","hidden_at","id","image","mimetype","tombstoned_at","torrent_id","updated_at"`
	var (
		c0 sql.NullString // archive_id
		c1 sql.NullString // auto_description
		c2 sql.NullInt64  // bytes
		c3 sql.NullString // description
		c4 sql.NullString // id
		c5 sql.NullString // image
		c6 sql.NullString // mimetype
		c7 sql.NullString
	)
	c0.Valid = true
	c0.String = a.ArchiveID
	c1.Valid = true
	c1.String = a.AutoDescription
	c2.Valid = true
	c2.Int64 = int64(a.Bytes)
	c3.Valid = true
	c3.String = a.Description
	c4.Valid = true
	c4.String = a.ID
	c5.Valid = true
	c5.String = a.Image
	c6.Valid = true
	c6.String = a.Mimetype
	c7.Valid = true
	c7.String = a.TorrentID // torrent_id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2, c3, c4, c5, c6, c7))
}

// MetadataDeleteByID generated by genieql
func MetadataDeleteByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `DELETE FROM library_metadata WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataTombstoneByID generated by genieql
func MetadataTombstoneByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET tombstoned_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataHideByID generated by genieql
func MetadataHideByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET hidden_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataFindByID generated by genieql
func MetadataFindByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `SELECT library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at" FROM library_metadata WHERE "id" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataFindByDescription generated by genieql
func MetadataFindByDescription(ctx context.Context, q sqlx.Queryer, desc string) MetadataScannerStaticRow {
	const query = `SELECT library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at" FROM library_metadata WHERE "description" = $1`
	var c0 sql.NullString // desc
	c0.Valid = true
	c0.String = desc
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataAssociateTorrent generated by genieql
func MetadataAssociateTorrent(ctx context.Context, q sqlx.Queryer, desc, tid string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET torrent_id = $2 WHERE "description" = $1 AND torrent_id = '00000000-0000-0000-0000-000000000000' RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // desc
		c1 sql.NullString // tid
	)
	c0.Valid = true
	c0.String = desc
	c1.Valid = true
	c1.String = tid
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}
