//go:build !genieql.ignore
// +build !genieql.ignore

package library

import (
	"context"
	"database/sql"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/retrovibed/retrovibed/internal/sqlx"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql auto -v -o genieql.gen.go
// invoked by go generate @ library/10_generate.genieql.go line 3

// Metadata generated by genieql
type Metadata struct {
	ArchiveID       string    `json:"archive_id"`
	AutoDescription string    `json:"auto_description"`
	Bytes           uint64    `json:"bytes"`
	CreatedAt       time.Time `json:"created_at"`
	Description     string    `json:"description"`
	HiddenAt        time.Time `json:"hidden_at"`
	ID              string    `json:"id"`
	Image           string    `json:"image"`
	KnownMediaID    string    `json:"known_media_id"`
	Mimetype        string    `json:"mimetype"`
	TombstonedAt    time.Time `json:"tombstoned_at"`
	TorrentID       string    `json:"torrent_id"`
	UpdatedAt       time.Time `json:"updated_at"`
}

// Known generated by genieql
type Known struct {
	Adult               bool    `json:"adult"`
	BackdropPath        string  `json:"backdrop_path"`
	Budget              int64   `json:"budget"`
	Genres              string  `json:"genres"`
	Homepage            string  `json:"homepage"`
	ID                  int64   `json:"id"`
	ImdbID              string  `json:"imdb_id"`
	Keywords            string  `json:"keywords"`
	OriginalLanguage    string  `json:"original_language"`
	OriginalTitle       string  `json:"original_title"`
	Overview            string  `json:"overview"`
	Popularity          float64 `json:"popularity"`
	PosterPath          string  `json:"poster_path"`
	ProductionCompanies string  `json:"production_companies"`
	ProductionCountries string  `json:"production_countries"`
	Revenue             int64   `json:"revenue"`
	Runtime             int64   `json:"runtime"`
	SpokenLanguages     string  `json:"spoken_languages"`
	Status              string  `json:"status"`
	Tagline             string  `json:"tagline"`
	Title               string  `json:"title"`
	UID                 string  `json:"uid"`
	VoteAverage         float64 `json:"vote_average"`
	VoteCount           int64   `json:"vote_count"`
}

// MetadataScanner scanner interface.
type MetadataScanner interface {
	Scan(i *Metadata) error
	Next() bool
	Close() error
	Err() error
}

type errMetadataScanner struct {
	e error
}

func (t errMetadataScanner) Scan(i *Metadata) error {
	return t.e
}

func (t errMetadataScanner) Next() bool {
	return false
}

func (t errMetadataScanner) Err() error {
	return t.e
}

func (t errMetadataScanner) Close() error {
	return nil
}

// MetadataScannerStaticColumns generated by genieql
const MetadataScannerStaticColumns = `library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`

// NewMetadataScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewMetadataScannerStatic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerStatic{
		Rows: rows,
	}
}

// metadataScannerStatic generated by genieql
type metadataScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t metadataScannerStatic) Scan(i *Metadata) error {
	var (
		c0  sql.NullString
		c1  sql.NullString
		c2  sql.NullInt64
		c3  sql.NullTime
		c4  sql.NullString
		c5  sql.NullTime
		c6  sql.NullString
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullString
		c10 sql.NullTime
		c11 sql.NullString
		c12 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12); err != nil {
		return err
	}

	if c0.Valid {
		if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
			return err
		} else {
			i.ArchiveID = uid.String()
		}
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		tmp := uint64(c2.Int64)
		i.Bytes = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.CreatedAt = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Description = tmp
	}

	if c5.Valid {
		tmp := c5.Time
		i.HiddenAt = tmp
	}

	if c6.Valid {
		if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.Image = tmp
	}

	if c8.Valid {
		if uid, err := uuid.FromBytes([]byte(c8.String)); err != nil {
			return err
		} else {
			i.KnownMediaID = uid.String()
		}
	}

	if c9.Valid {
		tmp := string(c9.String)
		i.Mimetype = tmp
	}

	if c10.Valid {
		tmp := c10.Time
		i.TombstonedAt = tmp
	}

	if c11.Valid {
		if uid, err := uuid.FromBytes([]byte(c11.String)); err != nil {
			return err
		} else {
			i.TorrentID = uid.String()
		}
	}

	if c12.Valid {
		tmp := c12.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewMetadataScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewMetadataScannerStaticRow(row *sql.Row) MetadataScannerStaticRow {
	return MetadataScannerStaticRow{
		row: row,
	}
}

// MetadataScannerStaticRow generated by genieql
type MetadataScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t MetadataScannerStaticRow) Scan(i *Metadata) error {
	var (
		c0  sql.NullString
		c1  sql.NullString
		c2  sql.NullInt64
		c3  sql.NullTime
		c4  sql.NullString
		c5  sql.NullTime
		c6  sql.NullString
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullString
		c10 sql.NullTime
		c11 sql.NullString
		c12 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12); err != nil {
		return err
	}

	if c0.Valid {
		if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
			return err
		} else {
			i.ArchiveID = uid.String()
		}
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		tmp := uint64(c2.Int64)
		i.Bytes = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.CreatedAt = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Description = tmp
	}

	if c5.Valid {
		tmp := c5.Time
		i.HiddenAt = tmp
	}

	if c6.Valid {
		if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.Image = tmp
	}

	if c8.Valid {
		if uid, err := uuid.FromBytes([]byte(c8.String)); err != nil {
			return err
		} else {
			i.KnownMediaID = uid.String()
		}
	}

	if c9.Valid {
		tmp := string(c9.String)
		i.Mimetype = tmp
	}

	if c10.Valid {
		tmp := c10.Time
		i.TombstonedAt = tmp
	}

	if c11.Valid {
		if uid, err := uuid.FromBytes([]byte(c11.String)); err != nil {
			return err
		} else {
			i.TorrentID = uid.String()
		}
	}

	if c12.Valid {
		tmp := c12.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t MetadataScannerStaticRow) Err(err error) MetadataScannerStaticRow {
	t.err = err
	return t
}

// NewMetadataScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewMetadataScannerDynamic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerDynamic{
		Rows: rows,
	}
}

// metadataScannerDynamic generated by genieql
type metadataScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t metadataScannerDynamic) Scan(i *Metadata) error {
	const (
		cn0  = "archive_id"
		cn1  = "auto_description"
		cn2  = "bytes"
		cn3  = "created_at"
		cn4  = "description"
		cn5  = "hidden_at"
		cn6  = "id"
		cn7  = "image"
		cn8  = "known_media_id"
		cn9  = "mimetype"
		cn10 = "tombstoned_at"
		cn11 = "torrent_id"
		cn12 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullString
		c1      sql.NullString
		c2      sql.NullInt64
		c3      sql.NullTime
		c4      sql.NullString
		c5      sql.NullTime
		c6      sql.NullString
		c7      sql.NullString
		c8      sql.NullString
		c9      sql.NullString
		c10     sql.NullTime
		c11     sql.NullString
		c12     sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		case cn8:
			dst = append(dst, &c8)
		case cn9:
			dst = append(dst, &c9)
		case cn10:
			dst = append(dst, &c10)
		case cn11:
			dst = append(dst, &c11)
		case cn12:
			dst = append(dst, &c12)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
					return err
				} else {
					i.ArchiveID = uid.String()
				}
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.AutoDescription = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := uint64(c2.Int64)
				i.Bytes = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := c3.Time
				i.CreatedAt = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := string(c4.String)
				i.Description = tmp
			}

		case cn5:
			if c5.Valid {
				tmp := c5.Time
				i.HiddenAt = tmp
			}

		case cn6:
			if c6.Valid {
				if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn7:
			if c7.Valid {
				tmp := string(c7.String)
				i.Image = tmp
			}

		case cn8:
			if c8.Valid {
				if uid, err := uuid.FromBytes([]byte(c8.String)); err != nil {
					return err
				} else {
					i.KnownMediaID = uid.String()
				}
			}

		case cn9:
			if c9.Valid {
				tmp := string(c9.String)
				i.Mimetype = tmp
			}

		case cn10:
			if c10.Valid {
				tmp := c10.Time
				i.TombstonedAt = tmp
			}

		case cn11:
			if c11.Valid {
				if uid, err := uuid.FromBytes([]byte(c11.String)); err != nil {
					return err
				} else {
					i.TorrentID = uid.String()
				}
			}

		case cn12:
			if c12.Valid {
				tmp := c12.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// KnownScanner scanner interface.
type KnownScanner interface {
	Scan(i *Known) error
	Next() bool
	Close() error
	Err() error
}

type errKnownScanner struct {
	e error
}

func (t errKnownScanner) Scan(i *Known) error {
	return t.e
}

func (t errKnownScanner) Next() bool {
	return false
}

func (t errKnownScanner) Err() error {
	return t.e
}

func (t errKnownScanner) Close() error {
	return nil
}

// KnownScannerStaticColumns generated by genieql
const KnownScannerStaticColumns = `library_known_media."adult",library_known_media."backdrop_path",library_known_media."budget",library_known_media."genres",library_known_media."homepage",library_known_media."id",library_known_media."imdb_id",library_known_media."keywords",library_known_media."original_language",library_known_media."original_title",library_known_media."overview",library_known_media."popularity",library_known_media."poster_path",library_known_media."production_companies",library_known_media."production_countries",library_known_media."revenue",library_known_media."runtime",library_known_media."spoken_languages",library_known_media."status",library_known_media."tagline",library_known_media."title",library_known_media."uid",library_known_media."vote_average",library_known_media."vote_count"`

// NewKnownScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewKnownScannerStatic(rows *sql.Rows, err error) KnownScanner {
	if err != nil {
		return errKnownScanner{e: err}
	}

	return knownScannerStatic{
		Rows: rows,
	}
}

// knownScannerStatic generated by genieql
type knownScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t knownScannerStatic) Scan(i *Known) error {
	var (
		c0  sql.NullBool
		c1  sql.NullString
		c2  sql.NullInt64
		c3  sql.NullString
		c4  sql.NullString
		c5  sql.NullInt64
		c6  sql.NullString
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullString
		c10 sql.NullString
		c11 sql.NullFloat64
		c12 sql.NullString
		c13 sql.NullString
		c14 sql.NullString
		c15 sql.NullInt64
		c16 sql.NullInt64
		c17 sql.NullString
		c18 sql.NullString
		c19 sql.NullString
		c20 sql.NullString
		c21 sql.NullString
		c22 sql.NullFloat64
		c23 sql.NullInt64
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Bool
		i.Adult = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.BackdropPath = tmp
	}

	if c2.Valid {
		tmp := int64(c2.Int64)
		i.Budget = tmp
	}

	if c3.Valid {
		tmp := string(c3.String)
		i.Genres = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Homepage = tmp
	}

	if c5.Valid {
		tmp := int64(c5.Int64)
		i.ID = tmp
	}

	if c6.Valid {
		tmp := string(c6.String)
		i.ImdbID = tmp
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.Keywords = tmp
	}

	if c8.Valid {
		tmp := string(c8.String)
		i.OriginalLanguage = tmp
	}

	if c9.Valid {
		tmp := string(c9.String)
		i.OriginalTitle = tmp
	}

	if c10.Valid {
		tmp := string(c10.String)
		i.Overview = tmp
	}

	if c11.Valid {
		tmp := float64(c11.Float64)
		i.Popularity = tmp
	}

	if c12.Valid {
		tmp := string(c12.String)
		i.PosterPath = tmp
	}

	if c13.Valid {
		tmp := string(c13.String)
		i.ProductionCompanies = tmp
	}

	if c14.Valid {
		tmp := string(c14.String)
		i.ProductionCountries = tmp
	}

	if c15.Valid {
		tmp := int64(c15.Int64)
		i.Revenue = tmp
	}

	if c16.Valid {
		tmp := int64(c16.Int64)
		i.Runtime = tmp
	}

	if c17.Valid {
		tmp := string(c17.String)
		i.SpokenLanguages = tmp
	}

	if c18.Valid {
		tmp := string(c18.String)
		i.Status = tmp
	}

	if c19.Valid {
		tmp := string(c19.String)
		i.Tagline = tmp
	}

	if c20.Valid {
		tmp := string(c20.String)
		i.Title = tmp
	}

	if c21.Valid {
		if uid, err := uuid.FromBytes([]byte(c21.String)); err != nil {
			return err
		} else {
			i.UID = uid.String()
		}
	}

	if c22.Valid {
		tmp := float64(c22.Float64)
		i.VoteAverage = tmp
	}

	if c23.Valid {
		tmp := int64(c23.Int64)
		i.VoteCount = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t knownScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t knownScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t knownScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewKnownScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewKnownScannerStaticRow(row *sql.Row) KnownScannerStaticRow {
	return KnownScannerStaticRow{
		row: row,
	}
}

// KnownScannerStaticRow generated by genieql
type KnownScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t KnownScannerStaticRow) Scan(i *Known) error {
	var (
		c0  sql.NullBool
		c1  sql.NullString
		c2  sql.NullInt64
		c3  sql.NullString
		c4  sql.NullString
		c5  sql.NullInt64
		c6  sql.NullString
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullString
		c10 sql.NullString
		c11 sql.NullFloat64
		c12 sql.NullString
		c13 sql.NullString
		c14 sql.NullString
		c15 sql.NullInt64
		c16 sql.NullInt64
		c17 sql.NullString
		c18 sql.NullString
		c19 sql.NullString
		c20 sql.NullString
		c21 sql.NullString
		c22 sql.NullFloat64
		c23 sql.NullInt64
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Bool
		i.Adult = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.BackdropPath = tmp
	}

	if c2.Valid {
		tmp := int64(c2.Int64)
		i.Budget = tmp
	}

	if c3.Valid {
		tmp := string(c3.String)
		i.Genres = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Homepage = tmp
	}

	if c5.Valid {
		tmp := int64(c5.Int64)
		i.ID = tmp
	}

	if c6.Valid {
		tmp := string(c6.String)
		i.ImdbID = tmp
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.Keywords = tmp
	}

	if c8.Valid {
		tmp := string(c8.String)
		i.OriginalLanguage = tmp
	}

	if c9.Valid {
		tmp := string(c9.String)
		i.OriginalTitle = tmp
	}

	if c10.Valid {
		tmp := string(c10.String)
		i.Overview = tmp
	}

	if c11.Valid {
		tmp := float64(c11.Float64)
		i.Popularity = tmp
	}

	if c12.Valid {
		tmp := string(c12.String)
		i.PosterPath = tmp
	}

	if c13.Valid {
		tmp := string(c13.String)
		i.ProductionCompanies = tmp
	}

	if c14.Valid {
		tmp := string(c14.String)
		i.ProductionCountries = tmp
	}

	if c15.Valid {
		tmp := int64(c15.Int64)
		i.Revenue = tmp
	}

	if c16.Valid {
		tmp := int64(c16.Int64)
		i.Runtime = tmp
	}

	if c17.Valid {
		tmp := string(c17.String)
		i.SpokenLanguages = tmp
	}

	if c18.Valid {
		tmp := string(c18.String)
		i.Status = tmp
	}

	if c19.Valid {
		tmp := string(c19.String)
		i.Tagline = tmp
	}

	if c20.Valid {
		tmp := string(c20.String)
		i.Title = tmp
	}

	if c21.Valid {
		if uid, err := uuid.FromBytes([]byte(c21.String)); err != nil {
			return err
		} else {
			i.UID = uid.String()
		}
	}

	if c22.Valid {
		tmp := float64(c22.Float64)
		i.VoteAverage = tmp
	}

	if c23.Valid {
		tmp := int64(c23.Int64)
		i.VoteCount = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t KnownScannerStaticRow) Err(err error) KnownScannerStaticRow {
	t.err = err
	return t
}

// NewKnownScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewKnownScannerDynamic(rows *sql.Rows, err error) KnownScanner {
	if err != nil {
		return errKnownScanner{e: err}
	}

	return knownScannerDynamic{
		Rows: rows,
	}
}

// knownScannerDynamic generated by genieql
type knownScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t knownScannerDynamic) Scan(i *Known) error {
	const (
		cn0  = "adult"
		cn1  = "backdrop_path"
		cn2  = "budget"
		cn3  = "genres"
		cn4  = "homepage"
		cn5  = "id"
		cn6  = "imdb_id"
		cn7  = "keywords"
		cn8  = "original_language"
		cn9  = "original_title"
		cn10 = "overview"
		cn11 = "popularity"
		cn12 = "poster_path"
		cn13 = "production_companies"
		cn14 = "production_countries"
		cn15 = "revenue"
		cn16 = "runtime"
		cn17 = "spoken_languages"
		cn18 = "status"
		cn19 = "tagline"
		cn20 = "title"
		cn21 = "uid"
		cn22 = "vote_average"
		cn23 = "vote_count"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullBool
		c1      sql.NullString
		c2      sql.NullInt64
		c3      sql.NullString
		c4      sql.NullString
		c5      sql.NullInt64
		c6      sql.NullString
		c7      sql.NullString
		c8      sql.NullString
		c9      sql.NullString
		c10     sql.NullString
		c11     sql.NullFloat64
		c12     sql.NullString
		c13     sql.NullString
		c14     sql.NullString
		c15     sql.NullInt64
		c16     sql.NullInt64
		c17     sql.NullString
		c18     sql.NullString
		c19     sql.NullString
		c20     sql.NullString
		c21     sql.NullString
		c22     sql.NullFloat64
		c23     sql.NullInt64
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		case cn8:
			dst = append(dst, &c8)
		case cn9:
			dst = append(dst, &c9)
		case cn10:
			dst = append(dst, &c10)
		case cn11:
			dst = append(dst, &c11)
		case cn12:
			dst = append(dst, &c12)
		case cn13:
			dst = append(dst, &c13)
		case cn14:
			dst = append(dst, &c14)
		case cn15:
			dst = append(dst, &c15)
		case cn16:
			dst = append(dst, &c16)
		case cn17:
			dst = append(dst, &c17)
		case cn18:
			dst = append(dst, &c18)
		case cn19:
			dst = append(dst, &c19)
		case cn20:
			dst = append(dst, &c20)
		case cn21:
			dst = append(dst, &c21)
		case cn22:
			dst = append(dst, &c22)
		case cn23:
			dst = append(dst, &c23)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Bool
				i.Adult = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.BackdropPath = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := int64(c2.Int64)
				i.Budget = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := string(c3.String)
				i.Genres = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := string(c4.String)
				i.Homepage = tmp
			}

		case cn5:
			if c5.Valid {
				tmp := int64(c5.Int64)
				i.ID = tmp
			}

		case cn6:
			if c6.Valid {
				tmp := string(c6.String)
				i.ImdbID = tmp
			}

		case cn7:
			if c7.Valid {
				tmp := string(c7.String)
				i.Keywords = tmp
			}

		case cn8:
			if c8.Valid {
				tmp := string(c8.String)
				i.OriginalLanguage = tmp
			}

		case cn9:
			if c9.Valid {
				tmp := string(c9.String)
				i.OriginalTitle = tmp
			}

		case cn10:
			if c10.Valid {
				tmp := string(c10.String)
				i.Overview = tmp
			}

		case cn11:
			if c11.Valid {
				tmp := float64(c11.Float64)
				i.Popularity = tmp
			}

		case cn12:
			if c12.Valid {
				tmp := string(c12.String)
				i.PosterPath = tmp
			}

		case cn13:
			if c13.Valid {
				tmp := string(c13.String)
				i.ProductionCompanies = tmp
			}

		case cn14:
			if c14.Valid {
				tmp := string(c14.String)
				i.ProductionCountries = tmp
			}

		case cn15:
			if c15.Valid {
				tmp := int64(c15.Int64)
				i.Revenue = tmp
			}

		case cn16:
			if c16.Valid {
				tmp := int64(c16.Int64)
				i.Runtime = tmp
			}

		case cn17:
			if c17.Valid {
				tmp := string(c17.String)
				i.SpokenLanguages = tmp
			}

		case cn18:
			if c18.Valid {
				tmp := string(c18.String)
				i.Status = tmp
			}

		case cn19:
			if c19.Valid {
				tmp := string(c19.String)
				i.Tagline = tmp
			}

		case cn20:
			if c20.Valid {
				tmp := string(c20.String)
				i.Title = tmp
			}

		case cn21:
			if c21.Valid {
				if uid, err := uuid.FromBytes([]byte(c21.String)); err != nil {
					return err
				} else {
					i.UID = uid.String()
				}
			}

		case cn22:
			if c22.Valid {
				tmp := float64(c22.Float64)
				i.VoteAverage = tmp
			}

		case cn23:
			if c23.Valid {
				tmp := int64(c23.Int64)
				i.VoteCount = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t knownScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t knownScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t knownScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// ScoredScanner scanner interface.
type ScoredScanner interface {
	Scan(relevance *float64) error
	Next() bool
	Close() error
	Err() error
}

type errScoredScanner struct {
	e error
}

func (t errScoredScanner) Scan(relevance *float64) error {
	return t.e
}

func (t errScoredScanner) Next() bool {
	return false
}

func (t errScoredScanner) Err() error {
	return t.e
}

func (t errScoredScanner) Close() error {
	return nil
}

// ScoredScannerStaticColumns generated by genieql
const ScoredScannerStaticColumns = ``

// NewScoredScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewScoredScannerStatic(rows *sql.Rows, err error) ScoredScanner {
	if err != nil {
		return errScoredScanner{e: err}
	}

	return scoredScannerStatic{
		Rows: rows,
	}
}

// scoredScannerStatic generated by genieql
type scoredScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t scoredScannerStatic) Scan(relevance *float64) error {
	var (
		c0 sql.NullFloat64
	)

	if err := t.Rows.Scan(&c0); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Float64
		*relevance = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t scoredScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t scoredScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t scoredScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewScoredScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewScoredScannerStaticRow(row *sql.Row) ScoredScannerStaticRow {
	return ScoredScannerStaticRow{
		row: row,
	}
}

// ScoredScannerStaticRow generated by genieql
type ScoredScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t ScoredScannerStaticRow) Scan(relevance *float64) error {
	var (
		c0 sql.NullFloat64
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Float64
		*relevance = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t ScoredScannerStaticRow) Err(err error) ScoredScannerStaticRow {
	t.err = err
	return t
}

// NewScoredScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewScoredScannerDynamic(rows *sql.Rows, err error) ScoredScanner {
	if err != nil {
		return errScoredScanner{e: err}
	}

	return scoredScannerDynamic{
		Rows: rows,
	}
}

// scoredScannerDynamic generated by genieql
type scoredScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t scoredScannerDynamic) Scan(relevance *float64) error {
	const (
		cn0 = "relevance"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullFloat64
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Float64
				*relevance = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t scoredScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t scoredScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t scoredScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// MetadataInsertWithDefaultsStaticColumns generated by genieql
const MetadataInsertWithDefaultsStaticColumns = `$1,$2,$3,DEFAULT,$4,DEFAULT,$5,$6,$7,$8,DEFAULT,$9,DEFAULT`

// MetadataInsertWithDefaultsExplode generated by genieql
func MetadataInsertWithDefaultsExplode(a *Metadata) ([]interface{}, error) {
	var (
		c0 sql.NullString // archive_id
		c1 sql.NullString // auto_description
		c2 sql.NullInt64  // bytes
		c3 sql.NullString // description
		c4 sql.NullString // id
		c5 sql.NullString // image
		c6 sql.NullString // known_media_id
		c7 sql.NullString // mimetype
		c8 sql.NullString // torrent_id
	)

	c0.Valid = true
	c0.String = a.ArchiveID

	c1.Valid = true
	c1.String = a.AutoDescription

	c2.Valid = true
	c2.Int64 = int64(a.Bytes)

	c3.Valid = true
	c3.String = a.Description

	c4.Valid = true
	c4.String = a.ID

	c5.Valid = true
	c5.String = a.Image

	c6.Valid = true
	c6.String = a.KnownMediaID

	c7.Valid = true
	c7.String = a.Mimetype

	c8.Valid = true
	c8.String = a.TorrentID

	return []interface{}{c0, c1, c2, c3, c4, c5, c6, c7, c8}, nil
}

// MetadataInsertWithDefaults generated by genieql
func MetadataInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Metadata) MetadataScannerStaticRow {
	const query = `INSERT INTO "library_metadata" ("archive_id","auto_description","bytes","created_at","description","hidden_at","id","image","known_media_id","mimetype","tombstoned_at","torrent_id","updated_at") VALUES ($1,$2,$3,DEFAULT,$4,DEFAULT,$5,$6,$7,$8,DEFAULT,$9,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT RETURNING "archive_id","auto_description","bytes","created_at","description","hidden_at","id","image","known_media_id","mimetype","tombstoned_at","torrent_id","updated_at"`
	var (
		c0 sql.NullString // archive_id
		c1 sql.NullString // auto_description
		c2 sql.NullInt64  // bytes
		c3 sql.NullString // description
		c4 sql.NullString // id
		c5 sql.NullString // image
		c6 sql.NullString // known_media_id
		c7 sql.NullString // mimetype
		c8 sql.NullString
	)
	c0.Valid = true
	c0.String = a.ArchiveID
	c1.Valid = true
	c1.String = a.AutoDescription
	c2.Valid = true
	c2.Int64 = int64(a.Bytes)
	c3.Valid = true
	c3.String = a.Description
	c4.Valid = true
	c4.String = a.ID
	c5.Valid = true
	c5.String = a.Image
	c6.Valid = true
	c6.String = a.KnownMediaID
	c7.Valid = true
	c7.String = a.Mimetype
	c8.Valid = true
	c8.String = a.TorrentID // torrent_id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2, c3, c4, c5, c6, c7, c8))
}

// MetadataDeleteByID generated by genieql
func MetadataDeleteByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `DELETE FROM library_metadata WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataTombstoneByID generated by genieql
func MetadataTombstoneByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET tombstoned_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataHideByID generated by genieql
func MetadataHideByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET hidden_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataUpdateAutodescriptionByID generated by genieql
func MetadataUpdateAutodescriptionByID(ctx context.Context, q sqlx.Queryer, id string, autodescription string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET updated_at = NOW(), auto_description = $2 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // autodescription
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = autodescription
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// MetadataUpdateDescriptionByID generated by genieql
func MetadataUpdateDescriptionByID(ctx context.Context, q sqlx.Queryer, id string, description string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET updated_at = NOW(), description = $2 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // description
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = description
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// MetadataFindByID generated by genieql
func MetadataFindByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `SELECT library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at" FROM library_metadata WHERE "id" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataFindByDescription generated by genieql
func MetadataFindByDescription(ctx context.Context, q sqlx.Queryer, desc string) MetadataScannerStaticRow {
	const query = `SELECT library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at" FROM library_metadata WHERE "description" = $1`
	var c0 sql.NullString // desc
	c0.Valid = true
	c0.String = desc
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataAssociateTorrent generated by genieql
func MetadataAssociateTorrent(ctx context.Context, q sqlx.Queryer, desc, tid string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET torrent_id = $2 WHERE "description" = $1 AND torrent_id = '00000000-0000-0000-0000-000000000000' RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // desc
		c1 sql.NullString // tid
	)
	c0.Valid = true
	c0.String = desc
	c1.Valid = true
	c1.String = tid
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// KnownFindByID generated by genieql
func KnownFindByID(ctx context.Context, q sqlx.Queryer, id string) KnownScannerStaticRow {
	const query = `SELECT library_known_media."adult",library_known_media."backdrop_path",library_known_media."budget",library_known_media."genres",library_known_media."homepage",library_known_media."id",library_known_media."imdb_id",library_known_media."keywords",library_known_media."original_language",library_known_media."original_title",library_known_media."overview",library_known_media."popularity",library_known_media."poster_path",library_known_media."production_companies",library_known_media."production_countries",library_known_media."revenue",library_known_media."runtime",library_known_media."spoken_languages",library_known_media."status",library_known_media."tagline",library_known_media."title",library_known_media."uid",library_known_media."vote_average",library_known_media."vote_count" FROM library_known_media WHERE "id" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewKnownScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// KnownScoreByID generated by genieql
func KnownScoreByID(ctx context.Context, q sqlx.Queryer, uid string, terms string) ScoredScannerStaticRow {
	const query = `SELECT fts_main_library_known_media.match_bm25(md5_lower, $2)::float AS relevance FROM library_known_media WHERE uid = $1`
	var (
		c0 sql.NullString // uid
		c1 sql.NullString // terms
	)
	c0.Valid = true
	c0.String = uid
	c1.Valid = true
	c1.String = terms
	return NewScoredScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}
