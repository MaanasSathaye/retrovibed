//go:build !genieql.ignore
// +build !genieql.ignore

package library

import (
	"context"
	"database/sql"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/retrovibed/retrovibed/internal/ducktype"
	"github.com/retrovibed/retrovibed/internal/sqlx"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql auto -v -o genieql.gen.go
// invoked by go generate @ library/10_generate.genieql.go line 3

// Metadata generated by genieql
type Metadata struct {
	ArchiveID       string    `json:"archive_id"`
	AutoDescription string    `json:"auto_description"`
	Bytes           uint64    `json:"bytes"`
	CreatedAt       time.Time `json:"created_at"`
	Description     string    `json:"description"`
	DiskOffset      uint64    `json:"disk_offset"`
	DiskUsage       uint64    `json:"disk_usage"`
	EncryptionSeed  string    `json:"encryption_seed"`
	HiddenAt        time.Time `json:"hidden_at"`
	ID              string    `json:"id"`
	Image           string    `json:"image"`
	KnownMediaID    string    `json:"known_media_id"`
	Mimetype        string    `json:"mimetype"`
	QuotaUsage      uint64    `json:"quota_usage"`
	TombstonedAt    time.Time `json:"tombstoned_at"`
	TorrentID       string    `json:"torrent_id"`
	UpdatedAt       time.Time `json:"updated_at"`
}

// Known generated by genieql
type Known struct {
	Adult            bool      `json:"adult"`
	AutoDescription  string    `json:"auto_description"`
	BackdropPath     string    `json:"backdrop_path"`
	Duplicates       int64     `json:"duplicates"`
	ID               string    `json:"id"`
	Md5              string    `json:"md_5"`
	Md5Lower         uint64    `json:"md_5_lower"`
	OriginalLanguage string    `json:"original_language"`
	OriginalTitle    string    `json:"original_title"`
	Overview         string    `json:"overview"`
	Popularity       float64   `json:"popularity"`
	PosterPath       string    `json:"poster_path"`
	Released         time.Time `json:"released"`
	Source           string    `json:"source"`
	Title            string    `json:"title"`
	UID              string    `json:"uid"`
}

// MetadataScanner scanner interface.
type MetadataScanner interface {
	Scan(i *Metadata) error
	Next() bool
	Close() error
	Err() error
}

type errMetadataScanner struct {
	e error
}

func (t errMetadataScanner) Scan(i *Metadata) error {
	return t.e
}

func (t errMetadataScanner) Next() bool {
	return false
}

func (t errMetadataScanner) Err() error {
	return t.e
}

func (t errMetadataScanner) Close() error {
	return nil
}

// MetadataScannerStaticColumns generated by genieql
const MetadataScannerStaticColumns = `library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`

// NewMetadataScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewMetadataScannerStatic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerStatic{
		Rows: rows,
	}
}

// metadataScannerStatic generated by genieql
type metadataScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t metadataScannerStatic) Scan(i *Metadata) error {
	var (
		c0  sql.NullString
		c1  sql.NullString
		c2  ducktype.NullUint64
		c3  sql.NullTime
		c4  sql.NullString
		c5  ducktype.NullUint64
		c6  ducktype.NullUint64
		c7  sql.NullString
		c8  sql.NullTime
		c9  sql.NullString
		c10 sql.NullString
		c11 sql.NullString
		c12 sql.NullString
		c13 ducktype.NullUint64
		c14 sql.NullTime
		c15 sql.NullString
		c16 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16); err != nil {
		return err
	}

	if c0.Valid {
		if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
			return err
		} else {
			i.ArchiveID = uid.String()
		}
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		i.Bytes = c2.V
	}

	if c3.Valid {
		tmp := c3.Time
		i.CreatedAt = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Description = tmp
	}

	if c5.Valid {
		i.DiskOffset = c5.V
	}

	if c6.Valid {
		i.DiskUsage = c6.V
	}

	if c7.Valid {
		if uid, err := uuid.FromBytes([]byte(c7.String)); err != nil {
			return err
		} else {
			i.EncryptionSeed = uid.String()
		}
	}

	if c8.Valid {
		tmp := c8.Time
		i.HiddenAt = tmp
	}

	if c9.Valid {
		if uid, err := uuid.FromBytes([]byte(c9.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c10.Valid {
		tmp := string(c10.String)
		i.Image = tmp
	}

	if c11.Valid {
		if uid, err := uuid.FromBytes([]byte(c11.String)); err != nil {
			return err
		} else {
			i.KnownMediaID = uid.String()
		}
	}

	if c12.Valid {
		tmp := string(c12.String)
		i.Mimetype = tmp
	}

	if c13.Valid {
		i.QuotaUsage = c13.V
	}

	if c14.Valid {
		tmp := c14.Time
		i.TombstonedAt = tmp
	}

	if c15.Valid {
		if uid, err := uuid.FromBytes([]byte(c15.String)); err != nil {
			return err
		} else {
			i.TorrentID = uid.String()
		}
	}

	if c16.Valid {
		tmp := c16.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewMetadataScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewMetadataScannerStaticRow(row *sql.Row) MetadataScannerStaticRow {
	return MetadataScannerStaticRow{
		row: row,
	}
}

// MetadataScannerStaticRow generated by genieql
type MetadataScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t MetadataScannerStaticRow) Scan(i *Metadata) error {
	var (
		c0  sql.NullString
		c1  sql.NullString
		c2  ducktype.NullUint64
		c3  sql.NullTime
		c4  sql.NullString
		c5  ducktype.NullUint64
		c6  ducktype.NullUint64
		c7  sql.NullString
		c8  sql.NullTime
		c9  sql.NullString
		c10 sql.NullString
		c11 sql.NullString
		c12 sql.NullString
		c13 ducktype.NullUint64
		c14 sql.NullTime
		c15 sql.NullString
		c16 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16); err != nil {
		return err
	}

	if c0.Valid {
		if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
			return err
		} else {
			i.ArchiveID = uid.String()
		}
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		i.Bytes = c2.V
	}

	if c3.Valid {
		tmp := c3.Time
		i.CreatedAt = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Description = tmp
	}

	if c5.Valid {
		i.DiskOffset = c5.V
	}

	if c6.Valid {
		i.DiskUsage = c6.V
	}

	if c7.Valid {
		if uid, err := uuid.FromBytes([]byte(c7.String)); err != nil {
			return err
		} else {
			i.EncryptionSeed = uid.String()
		}
	}

	if c8.Valid {
		tmp := c8.Time
		i.HiddenAt = tmp
	}

	if c9.Valid {
		if uid, err := uuid.FromBytes([]byte(c9.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c10.Valid {
		tmp := string(c10.String)
		i.Image = tmp
	}

	if c11.Valid {
		if uid, err := uuid.FromBytes([]byte(c11.String)); err != nil {
			return err
		} else {
			i.KnownMediaID = uid.String()
		}
	}

	if c12.Valid {
		tmp := string(c12.String)
		i.Mimetype = tmp
	}

	if c13.Valid {
		i.QuotaUsage = c13.V
	}

	if c14.Valid {
		tmp := c14.Time
		i.TombstonedAt = tmp
	}

	if c15.Valid {
		if uid, err := uuid.FromBytes([]byte(c15.String)); err != nil {
			return err
		} else {
			i.TorrentID = uid.String()
		}
	}

	if c16.Valid {
		tmp := c16.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t MetadataScannerStaticRow) Err(err error) MetadataScannerStaticRow {
	t.err = err
	return t
}

// NewMetadataScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewMetadataScannerDynamic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerDynamic{
		Rows: rows,
	}
}

// metadataScannerDynamic generated by genieql
type metadataScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t metadataScannerDynamic) Scan(i *Metadata) error {
	const (
		cn0  = "archive_id"
		cn1  = "auto_description"
		cn2  = "bytes"
		cn3  = "created_at"
		cn4  = "description"
		cn5  = "disk_offset"
		cn6  = "disk_usage"
		cn7  = "encryption_seed"
		cn8  = "hidden_at"
		cn9  = "id"
		cn10 = "image"
		cn11 = "known_media_id"
		cn12 = "mimetype"
		cn13 = "quota_usage"
		cn14 = "tombstoned_at"
		cn15 = "torrent_id"
		cn16 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullString
		c1      sql.NullString
		c2      ducktype.NullUint64
		c3      sql.NullTime
		c4      sql.NullString
		c5      ducktype.NullUint64
		c6      ducktype.NullUint64
		c7      sql.NullString
		c8      sql.NullTime
		c9      sql.NullString
		c10     sql.NullString
		c11     sql.NullString
		c12     sql.NullString
		c13     ducktype.NullUint64
		c14     sql.NullTime
		c15     sql.NullString
		c16     sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		case cn8:
			dst = append(dst, &c8)
		case cn9:
			dst = append(dst, &c9)
		case cn10:
			dst = append(dst, &c10)
		case cn11:
			dst = append(dst, &c11)
		case cn12:
			dst = append(dst, &c12)
		case cn13:
			dst = append(dst, &c13)
		case cn14:
			dst = append(dst, &c14)
		case cn15:
			dst = append(dst, &c15)
		case cn16:
			dst = append(dst, &c16)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
					return err
				} else {
					i.ArchiveID = uid.String()
				}
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.AutoDescription = tmp
			}

		case cn2:
			if c2.Valid {
				i.Bytes = c2.V
			}

		case cn3:
			if c3.Valid {
				tmp := c3.Time
				i.CreatedAt = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := string(c4.String)
				i.Description = tmp
			}

		case cn5:
			if c5.Valid {
				i.DiskOffset = c5.V
			}

		case cn6:
			if c6.Valid {
				i.DiskUsage = c6.V
			}

		case cn7:
			if c7.Valid {
				if uid, err := uuid.FromBytes([]byte(c7.String)); err != nil {
					return err
				} else {
					i.EncryptionSeed = uid.String()
				}
			}

		case cn8:
			if c8.Valid {
				tmp := c8.Time
				i.HiddenAt = tmp
			}

		case cn9:
			if c9.Valid {
				if uid, err := uuid.FromBytes([]byte(c9.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn10:
			if c10.Valid {
				tmp := string(c10.String)
				i.Image = tmp
			}

		case cn11:
			if c11.Valid {
				if uid, err := uuid.FromBytes([]byte(c11.String)); err != nil {
					return err
				} else {
					i.KnownMediaID = uid.String()
				}
			}

		case cn12:
			if c12.Valid {
				tmp := string(c12.String)
				i.Mimetype = tmp
			}

		case cn13:
			if c13.Valid {
				i.QuotaUsage = c13.V
			}

		case cn14:
			if c14.Valid {
				tmp := c14.Time
				i.TombstonedAt = tmp
			}

		case cn15:
			if c15.Valid {
				if uid, err := uuid.FromBytes([]byte(c15.String)); err != nil {
					return err
				} else {
					i.TorrentID = uid.String()
				}
			}

		case cn16:
			if c16.Valid {
				tmp := c16.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// KnownScanner scanner interface.
type KnownScanner interface {
	Scan(i *Known) error
	Next() bool
	Close() error
	Err() error
}

type errKnownScanner struct {
	e error
}

func (t errKnownScanner) Scan(i *Known) error {
	return t.e
}

func (t errKnownScanner) Next() bool {
	return false
}

func (t errKnownScanner) Err() error {
	return t.e
}

func (t errKnownScanner) Close() error {
	return nil
}

// KnownScannerStaticColumns generated by genieql
const KnownScannerStaticColumns = `library_known_media."adult",library_known_media."auto_description",library_known_media."backdrop_path",library_known_media."duplicates",library_known_media."id",library_known_media."md5",library_known_media."md5_lower",library_known_media."original_language",library_known_media."original_title",library_known_media."overview",library_known_media."popularity",library_known_media."poster_path",library_known_media."released",library_known_media."source",library_known_media."title",library_known_media."uid"`

// NewKnownScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewKnownScannerStatic(rows *sql.Rows, err error) KnownScanner {
	if err != nil {
		return errKnownScanner{e: err}
	}

	return knownScannerStatic{
		Rows: rows,
	}
}

// knownScannerStatic generated by genieql
type knownScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t knownScannerStatic) Scan(i *Known) error {
	var (
		c0  sql.NullBool
		c1  sql.NullString
		c2  sql.NullString
		c3  sql.NullInt64
		c4  sql.NullString
		c5  sql.NullString
		c6  ducktype.NullUint64
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullString
		c10 sql.NullFloat64
		c11 sql.NullString
		c12 sql.NullTime
		c13 sql.NullString
		c14 sql.NullString
		c15 sql.NullString
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Bool
		i.Adult = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		tmp := string(c2.String)
		i.BackdropPath = tmp
	}

	if c3.Valid {
		tmp := int64(c3.Int64)
		i.Duplicates = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.ID = tmp
	}

	if c5.Valid {
		if uid, err := uuid.FromBytes([]byte(c5.String)); err != nil {
			return err
		} else {
			i.Md5 = uid.String()
		}
	}

	if c6.Valid {
		i.Md5Lower = c6.V
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.OriginalLanguage = tmp
	}

	if c8.Valid {
		tmp := string(c8.String)
		i.OriginalTitle = tmp
	}

	if c9.Valid {
		tmp := string(c9.String)
		i.Overview = tmp
	}

	if c10.Valid {
		tmp := float64(c10.Float64)
		i.Popularity = tmp
	}

	if c11.Valid {
		tmp := string(c11.String)
		i.PosterPath = tmp
	}

	if c12.Valid {
		tmp := c12.Time
		i.Released = tmp
	}

	if c13.Valid {
		tmp := string(c13.String)
		i.Source = tmp
	}

	if c14.Valid {
		tmp := string(c14.String)
		i.Title = tmp
	}

	if c15.Valid {
		if uid, err := uuid.FromBytes([]byte(c15.String)); err != nil {
			return err
		} else {
			i.UID = uid.String()
		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t knownScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t knownScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t knownScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewKnownScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewKnownScannerStaticRow(row *sql.Row) KnownScannerStaticRow {
	return KnownScannerStaticRow{
		row: row,
	}
}

// KnownScannerStaticRow generated by genieql
type KnownScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t KnownScannerStaticRow) Scan(i *Known) error {
	var (
		c0  sql.NullBool
		c1  sql.NullString
		c2  sql.NullString
		c3  sql.NullInt64
		c4  sql.NullString
		c5  sql.NullString
		c6  ducktype.NullUint64
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullString
		c10 sql.NullFloat64
		c11 sql.NullString
		c12 sql.NullTime
		c13 sql.NullString
		c14 sql.NullString
		c15 sql.NullString
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Bool
		i.Adult = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		tmp := string(c2.String)
		i.BackdropPath = tmp
	}

	if c3.Valid {
		tmp := int64(c3.Int64)
		i.Duplicates = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.ID = tmp
	}

	if c5.Valid {
		if uid, err := uuid.FromBytes([]byte(c5.String)); err != nil {
			return err
		} else {
			i.Md5 = uid.String()
		}
	}

	if c6.Valid {
		i.Md5Lower = c6.V
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.OriginalLanguage = tmp
	}

	if c8.Valid {
		tmp := string(c8.String)
		i.OriginalTitle = tmp
	}

	if c9.Valid {
		tmp := string(c9.String)
		i.Overview = tmp
	}

	if c10.Valid {
		tmp := float64(c10.Float64)
		i.Popularity = tmp
	}

	if c11.Valid {
		tmp := string(c11.String)
		i.PosterPath = tmp
	}

	if c12.Valid {
		tmp := c12.Time
		i.Released = tmp
	}

	if c13.Valid {
		tmp := string(c13.String)
		i.Source = tmp
	}

	if c14.Valid {
		tmp := string(c14.String)
		i.Title = tmp
	}

	if c15.Valid {
		if uid, err := uuid.FromBytes([]byte(c15.String)); err != nil {
			return err
		} else {
			i.UID = uid.String()
		}
	}

	return nil
}

// Err set an error to return by scan
func (t KnownScannerStaticRow) Err(err error) KnownScannerStaticRow {
	t.err = err
	return t
}

// NewKnownScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewKnownScannerDynamic(rows *sql.Rows, err error) KnownScanner {
	if err != nil {
		return errKnownScanner{e: err}
	}

	return knownScannerDynamic{
		Rows: rows,
	}
}

// knownScannerDynamic generated by genieql
type knownScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t knownScannerDynamic) Scan(i *Known) error {
	const (
		cn0  = "adult"
		cn1  = "auto_description"
		cn2  = "backdrop_path"
		cn3  = "duplicates"
		cn4  = "id"
		cn5  = "md5"
		cn6  = "md5_lower"
		cn7  = "original_language"
		cn8  = "original_title"
		cn9  = "overview"
		cn10 = "popularity"
		cn11 = "poster_path"
		cn12 = "released"
		cn13 = "source"
		cn14 = "title"
		cn15 = "uid"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullBool
		c1      sql.NullString
		c2      sql.NullString
		c3      sql.NullInt64
		c4      sql.NullString
		c5      sql.NullString
		c6      ducktype.NullUint64
		c7      sql.NullString
		c8      sql.NullString
		c9      sql.NullString
		c10     sql.NullFloat64
		c11     sql.NullString
		c12     sql.NullTime
		c13     sql.NullString
		c14     sql.NullString
		c15     sql.NullString
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		case cn8:
			dst = append(dst, &c8)
		case cn9:
			dst = append(dst, &c9)
		case cn10:
			dst = append(dst, &c10)
		case cn11:
			dst = append(dst, &c11)
		case cn12:
			dst = append(dst, &c12)
		case cn13:
			dst = append(dst, &c13)
		case cn14:
			dst = append(dst, &c14)
		case cn15:
			dst = append(dst, &c15)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Bool
				i.Adult = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.AutoDescription = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := string(c2.String)
				i.BackdropPath = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := int64(c3.Int64)
				i.Duplicates = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := string(c4.String)
				i.ID = tmp
			}

		case cn5:
			if c5.Valid {
				if uid, err := uuid.FromBytes([]byte(c5.String)); err != nil {
					return err
				} else {
					i.Md5 = uid.String()
				}
			}

		case cn6:
			if c6.Valid {
				i.Md5Lower = c6.V
			}

		case cn7:
			if c7.Valid {
				tmp := string(c7.String)
				i.OriginalLanguage = tmp
			}

		case cn8:
			if c8.Valid {
				tmp := string(c8.String)
				i.OriginalTitle = tmp
			}

		case cn9:
			if c9.Valid {
				tmp := string(c9.String)
				i.Overview = tmp
			}

		case cn10:
			if c10.Valid {
				tmp := float64(c10.Float64)
				i.Popularity = tmp
			}

		case cn11:
			if c11.Valid {
				tmp := string(c11.String)
				i.PosterPath = tmp
			}

		case cn12:
			if c12.Valid {
				tmp := c12.Time
				i.Released = tmp
			}

		case cn13:
			if c13.Valid {
				tmp := string(c13.String)
				i.Source = tmp
			}

		case cn14:
			if c14.Valid {
				tmp := string(c14.String)
				i.Title = tmp
			}

		case cn15:
			if c15.Valid {
				if uid, err := uuid.FromBytes([]byte(c15.String)); err != nil {
					return err
				} else {
					i.UID = uid.String()
				}
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t knownScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t knownScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t knownScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// ScoredScanner scanner interface.
type ScoredScanner interface {
	Scan(relevance *float64) error
	Next() bool
	Close() error
	Err() error
}

type errScoredScanner struct {
	e error
}

func (t errScoredScanner) Scan(relevance *float64) error {
	return t.e
}

func (t errScoredScanner) Next() bool {
	return false
}

func (t errScoredScanner) Err() error {
	return t.e
}

func (t errScoredScanner) Close() error {
	return nil
}

// ScoredScannerStaticColumns generated by genieql
const ScoredScannerStaticColumns = ``

// NewScoredScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewScoredScannerStatic(rows *sql.Rows, err error) ScoredScanner {
	if err != nil {
		return errScoredScanner{e: err}
	}

	return scoredScannerStatic{
		Rows: rows,
	}
}

// scoredScannerStatic generated by genieql
type scoredScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t scoredScannerStatic) Scan(relevance *float64) error {
	var (
		c0 sql.NullFloat64
	)

	if err := t.Rows.Scan(&c0); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Float64
		*relevance = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t scoredScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t scoredScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t scoredScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewScoredScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewScoredScannerStaticRow(row *sql.Row) ScoredScannerStaticRow {
	return ScoredScannerStaticRow{
		row: row,
	}
}

// ScoredScannerStaticRow generated by genieql
type ScoredScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t ScoredScannerStaticRow) Scan(relevance *float64) error {
	var (
		c0 sql.NullFloat64
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Float64
		*relevance = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t ScoredScannerStaticRow) Err(err error) ScoredScannerStaticRow {
	t.err = err
	return t
}

// NewScoredScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewScoredScannerDynamic(rows *sql.Rows, err error) ScoredScanner {
	if err != nil {
		return errScoredScanner{e: err}
	}

	return scoredScannerDynamic{
		Rows: rows,
	}
}

// scoredScannerDynamic generated by genieql
type scoredScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t scoredScannerDynamic) Scan(relevance *float64) error {
	const (
		cn0 = "relevance"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullFloat64
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Float64
				*relevance = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t scoredScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t scoredScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t scoredScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// MetadataArchivedByID generated by genieql
func MetadataArchivedByID(ctx context.Context, q sqlx.Queryer, id, aid string, quota uint64) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET archive_id = $2, quota_usage = $3 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // aid
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = aid
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, quota))
}

// MetadataForTorrentArchiveRetrieval generated by genieql
func MetadataForTorrentArchiveRetrieval(ctx context.Context, q sqlx.Queryer, infohash []byte, offset uint64, length uint64) MetadataScanner {
	const query = `SELECT library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at" FROM library_metadata INNER JOIN torrents_metadata AS tmd ON library_metadata.torrent_id = tmd.id WHERE to_hex(tmd.infohash) = to_hex($1) AND $2 BETWEEN disk_offset AND library_metadata.bytes AND library_metadata.archive_id NOT IN ('ffffffff-ffff-ffff-ffff-ffffffffffff', '00000000-0000-0000-0000-000000000000')`
	return NewMetadataScannerStatic(q.QueryContext(ctx, query, infohash, offset))
}

// MetadataUpdateAutodescriptionByID generated by genieql
func MetadataUpdateAutodescriptionByID(ctx context.Context, q sqlx.Queryer, id string, autodescription string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET updated_at = NOW(), auto_description = $2 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // autodescription
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = autodescription
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// MetadataUpdateDescriptionByID generated by genieql
func MetadataUpdateDescriptionByID(ctx context.Context, q sqlx.Queryer, id string, description string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET updated_at = NOW(), description = $2 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // description
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = description
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// MetadataFindByID generated by genieql
func MetadataFindByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `SELECT library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at" FROM library_metadata WHERE "id" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataFindByDescription generated by genieql
func MetadataFindByDescription(ctx context.Context, q sqlx.Queryer, desc string) MetadataScannerStaticRow {
	const query = `SELECT library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at" FROM library_metadata WHERE "description" = $1`
	var c0 sql.NullString // desc
	c0.Valid = true
	c0.String = desc
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataAssociateTorrent generated by genieql
func MetadataAssociateTorrent(ctx context.Context, q sqlx.Queryer, desc, tid string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET torrent_id = $2 WHERE "description" = $1 AND torrent_id = '00000000-0000-0000-0000-000000000000' RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // desc
		c1 sql.NullString // tid
	)
	c0.Valid = true
	c0.String = desc
	c1.Valid = true
	c1.String = tid
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// MetadataUpdate generated by genieql
func MetadataUpdate(ctx context.Context, q sqlx.Queryer, id string, md Metadata) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET description = $2, known_media_id = $3 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // description
		c2 sql.NullString // known_media_id
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = md.Description
	c2.Valid = true
	c2.String = md.KnownMediaID
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2))
}

// MetadataTransferKnownMediaIDFromTorrent generated by genieql
func MetadataTransferKnownMediaIDFromTorrent(ctx context.Context, q sqlx.Queryer, ts time.Time) MetadataScanner {
	const query = `UPDATE library_metadata SET updated_at = NOW(), known_media_id = t.known_media_id FROM torrents_metadata AS t WHERE t.id = library_metadata.torrent_id AND t."updated_at" >= $1 AND library_metadata.known_media_id = 'ffffffff-ffff-ffff-ffff-ffffffffffff' AND t.known_media_id NOT IN ('ffffffff-ffff-ffff-ffff-ffffffffffff', '00000000-0000-0000-0000-000000000000') RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullTime // ts
	c0.Valid = true
	c0.Time = ts
	return NewMetadataScannerStatic(q.QueryContext(ctx, query, c0))
}

// MetadataHideByID generated by genieql
func MetadataHideByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET hidden_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataTombstoneByID generated by genieql
func MetadataTombstoneByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET tombstoned_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataDeleteByID generated by genieql
func MetadataDeleteByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `DELETE FROM library_metadata WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."quota_usage",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataInsertWithDefaultsStaticColumns generated by genieql
const MetadataInsertWithDefaultsStaticColumns = `$1,$2,$3,DEFAULT,$4,$5,$6,$7,DEFAULT,$8,$9,$10,$11,$12,DEFAULT,$13,DEFAULT`

// MetadataInsertWithDefaultsExplode generated by genieql
func MetadataInsertWithDefaultsExplode(a *Metadata) ([]interface{}, error) {
	var (
		c0  sql.NullString      // archive_id
		c1  sql.NullString      // auto_description
		c2  ducktype.NullUint64 // bytes
		c3  sql.NullString      // description
		c4  ducktype.NullUint64 // disk_offset
		c5  ducktype.NullUint64 // disk_usage
		c6  sql.NullString      // encryption_seed
		c7  sql.NullString      // id
		c8  sql.NullString      // image
		c9  sql.NullString      // known_media_id
		c10 sql.NullString      // mimetype
		c11 ducktype.NullUint64 // quota_usage
		c12 sql.NullString      // torrent_id
	)

	c0.Valid = true
	c0.String = a.ArchiveID

	c1.Valid = true
	c1.String = a.AutoDescription

	c2.Valid = true
	c2.V = a.Bytes

	c3.Valid = true
	c3.String = a.Description

	c4.Valid = true
	c4.V = a.DiskOffset

	c5.Valid = true
	c5.V = a.DiskUsage

	c6.Valid = true
	c6.String = a.EncryptionSeed

	c7.Valid = true
	c7.String = a.ID

	c8.Valid = true
	c8.String = a.Image

	c9.Valid = true
	c9.String = a.KnownMediaID

	c10.Valid = true
	c10.String = a.Mimetype

	c11.Valid = true
	c11.V = a.QuotaUsage

	c12.Valid = true
	c12.String = a.TorrentID

	return []interface{}{c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12}, nil
}

// MetadataInsertWithDefaults generated by genieql
func MetadataInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Metadata) MetadataScannerStaticRow {
	const query = `INSERT INTO "library_metadata" ("archive_id","auto_description","bytes","created_at","description","disk_offset","disk_usage","encryption_seed","hidden_at","id","image","known_media_id","mimetype","quota_usage","tombstoned_at","torrent_id","updated_at") VALUES ($1,$2,$3,DEFAULT,$4,$5,$6,$7,DEFAULT,$8,$9,$10,$11,$12,DEFAULT,$13,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT, archive_id = CASE WHEN archive_id IN ('ffffffff-ffff-ffff-ffff-ffffffffffff', '00000000-0000-0000-0000-000000000000') THEN EXCLUDED.archive_id ELSE archive_id END RETURNING "archive_id","auto_description","bytes","created_at","description","disk_offset","disk_usage","encryption_seed","hidden_at","id","image","known_media_id","mimetype","quota_usage","tombstoned_at","torrent_id","updated_at"`
	var (
		c0  sql.NullString      // archive_id
		c1  sql.NullString      // auto_description
		c2  ducktype.NullUint64 // bytes
		c3  sql.NullString      // description
		c4  ducktype.NullUint64 // disk_offset
		c5  ducktype.NullUint64 // disk_usage
		c6  sql.NullString      // encryption_seed
		c7  sql.NullString      // id
		c8  sql.NullString      // image
		c9  sql.NullString      // known_media_id
		c10 sql.NullString      // mimetype
		c11 ducktype.NullUint64 // quota_usage
		c12 sql.NullString
	)
	c0.Valid = true
	c0.String = a.ArchiveID
	c1.Valid = true
	c1.String = a.AutoDescription
	c2.Valid = true
	c2.V = a.Bytes
	c3.Valid = true
	c3.String = a.Description
	c4.Valid = true
	c4.V = a.DiskOffset
	c5.Valid = true
	c5.V = a.DiskUsage
	c6.Valid = true
	c6.String = a.EncryptionSeed
	c7.Valid = true
	c7.String = a.ID
	c8.Valid = true
	c8.String = a.Image
	c9.Valid = true
	c9.String = a.KnownMediaID
	c10.Valid = true
	c10.String = a.Mimetype
	c11.Valid = true
	c11.V = a.QuotaUsage
	c12.Valid = true
	c12.String = a.TorrentID // torrent_id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12))
}

// KnownInsertWithDefaultsStaticColumns generated by genieql
const KnownInsertWithDefaultsStaticColumns = `$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16`

// KnownInsertWithDefaultsExplode generated by genieql
func KnownInsertWithDefaultsExplode(a *Known) ([]interface{}, error) {
	var (
		c0  sql.NullBool        // adult
		c1  sql.NullString      // auto_description
		c2  sql.NullString      // backdrop_path
		c3  sql.NullInt64       // duplicates
		c4  sql.NullString      // id
		c5  sql.NullString      // md5
		c6  ducktype.NullUint64 // md5_lower
		c7  sql.NullString      // original_language
		c8  sql.NullString      // original_title
		c9  sql.NullString      // overview
		c10 sql.NullFloat64     // popularity
		c11 sql.NullString      // poster_path
		c12 sql.NullTime        // released
		c13 sql.NullString      // source
		c14 sql.NullString      // title
		c15 sql.NullString      // uid
	)

	c0.Valid = true
	c0.Bool = a.Adult

	c1.Valid = true
	c1.String = a.AutoDescription

	c2.Valid = true
	c2.String = a.BackdropPath

	c3.Valid = true
	c3.Int64 = int64(a.Duplicates)

	c4.Valid = true
	c4.String = a.ID

	c5.Valid = true
	c5.String = a.Md5

	c6.Valid = true
	c6.V = a.Md5Lower

	c7.Valid = true
	c7.String = a.OriginalLanguage

	c8.Valid = true
	c8.String = a.OriginalTitle

	c9.Valid = true
	c9.String = a.Overview

	c10.Valid = true
	c10.Float64 = float64(a.Popularity)

	c11.Valid = true
	c11.String = a.PosterPath

	c12.Valid = true
	c12.Time = a.Released

	c13.Valid = true
	c13.String = a.Source

	c14.Valid = true
	c14.String = a.Title

	c15.Valid = true
	c15.String = a.UID

	return []interface{}{c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15}, nil
}

// KnownInsertWithDefaults generated by genieql
func KnownInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Known) KnownScannerStaticRow {
	const query = `INSERT INTO "library_known_media" ("adult","auto_description","backdrop_path","duplicates","id","md5","md5_lower","original_language","original_title","overview","popularity","poster_path","released","source","title","uid") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16) ON CONFLICT (uid) DO UPDATE SET title = EXCLUDED.title, original_language = EXCLUDED.original_language, original_title = EXCLUDED.original_title, popularity = EXCLUDED.popularity, overview = EXCLUDED.overview, source = EXCLUDED.source, poster_path = EXCLUDED.poster_path, backdrop_path = EXCLUDED.backdrop_path, duplicates = duplicates + 1 RETURNING "adult","auto_description","backdrop_path","duplicates","id","md5","md5_lower","original_language","original_title","overview","popularity","poster_path","released","source","title","uid"`
	var (
		c0  sql.NullBool        // adult
		c1  sql.NullString      // auto_description
		c2  sql.NullString      // backdrop_path
		c3  sql.NullInt64       // duplicates
		c4  sql.NullString      // id
		c5  sql.NullString      // md5
		c6  ducktype.NullUint64 // md5_lower
		c7  sql.NullString      // original_language
		c8  sql.NullString      // original_title
		c9  sql.NullString      // overview
		c10 sql.NullFloat64     // popularity
		c11 sql.NullString      // poster_path
		c12 sql.NullTime        // released
		c13 sql.NullString      // source
		c14 sql.NullString      // title
		c15 sql.NullString
	)
	c0.Valid = true
	c0.Bool = a.Adult
	c1.Valid = true
	c1.String = a.AutoDescription
	c2.Valid = true
	c2.String = a.BackdropPath
	c3.Valid = true
	c3.Int64 = int64(a.Duplicates)
	c4.Valid = true
	c4.String = a.ID
	c5.Valid = true
	c5.String = a.Md5
	c6.Valid = true
	c6.V = a.Md5Lower
	c7.Valid = true
	c7.String = a.OriginalLanguage
	c8.Valid = true
	c8.String = a.OriginalTitle
	c9.Valid = true
	c9.String = a.Overview
	c10.Valid = true
	c10.Float64 = float64(a.Popularity)
	c11.Valid = true
	c11.String = a.PosterPath
	c12.Valid = true
	c12.Time = a.Released
	c13.Valid = true
	c13.String = a.Source
	c14.Valid = true
	c14.String = a.Title
	c15.Valid = true
	c15.String = a.UID // uid
	return NewKnownScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15))
}

// KnownFindByID generated by genieql
func KnownFindByID(ctx context.Context, q sqlx.Queryer, id string) KnownScannerStaticRow {
	const query = `SELECT library_known_media."adult",library_known_media."auto_description",library_known_media."backdrop_path",library_known_media."duplicates",library_known_media."id",library_known_media."md5",library_known_media."md5_lower",library_known_media."original_language",library_known_media."original_title",library_known_media."overview",library_known_media."popularity",library_known_media."poster_path",library_known_media."released",library_known_media."source",library_known_media."title",library_known_media."uid" FROM library_known_media WHERE "uid" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewKnownScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// KnownScoreByID generated by genieql
func KnownScoreByID(ctx context.Context, q sqlx.Queryer, uid string, terms string) ScoredScannerStaticRow {
	const query = `SELECT COALESCE(fts_main_library_known_media.match_bm25(md5_lower, $2), 0.0)::float AS relevance FROM library_known_media WHERE uid = $1`
	var (
		c0 sql.NullString // uid
		c1 sql.NullString // terms
	)
	c0.Valid = true
	c0.String = uid
	c1.Valid = true
	c1.String = terms
	return NewScoredScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// KnownBestMatch generated by genieql
func KnownBestMatch(ctx context.Context, q sqlx.Queryer, terms string, cutoff float32) KnownScannerStaticRow {
	const query = `WITH scored AS (SELECT uid, $1 as q, (jaro_winkler_similarity(title, q, $2) + jaro_similarity(title, q, $2)) / 2 AS relevance FROM library_known_media WHERE NOT adult ORDER BY relevance DESC) SELECT library_known_media."adult",library_known_media."auto_description",library_known_media."backdrop_path",library_known_media."duplicates",library_known_media."id",library_known_media."md5",library_known_media."md5_lower",library_known_media."original_language",library_known_media."original_title",library_known_media."overview",library_known_media."popularity",library_known_media."poster_path",library_known_media."released",library_known_media."source",library_known_media."title",library_known_media."uid" FROM library_known_media INNER JOIN scored ON library_known_media.uid = scored.uid WHERE scored.relevance > $2 ORDER BY scored.relevance DESC`
	var (
		c0 sql.NullString  // terms
		c1 sql.NullFloat64 // cutoff
	)
	c0.Valid = true
	c0.String = terms
	c1.Valid = true
	c1.Float64 = float64(cutoff)
	return NewKnownScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}
