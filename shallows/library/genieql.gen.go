//go:build !genieql.ignore
// +build !genieql.ignore

package tracking

import (
	"context"
	"database/sql"
	"time"

	"github.com/gofrs/uuid"
	"github.com/james-lawrence/deeppool/internal/x/sqlx"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql auto -v -o genieql.gen.go
// invoked by go generate @ tracking/10_generate.genieql.go line 3

// Metadata generated by genieql
//
//easyjson:json
type Metadata struct {
	ArchiveID    string
	Bytes        uint64
	CreatedAt    time.Time
	Description  string
	HiddenAt     time.Time
	ID           string
	Mimetype     string
	TombstonedAt time.Time
	TorrentID    string
	UpdatedAt    time.Time
}

// MetadataScanner scanner interface.
type MetadataScanner interface {
	Scan(i *Metadata) error
	Next() bool
	Close() error
	Err() error
}

type errMetadataScanner struct {
	e error
}

func (t errMetadataScanner) Scan(i *Metadata) error {
	return t.e
}

func (t errMetadataScanner) Next() bool {
	return false
}

func (t errMetadataScanner) Err() error {
	return t.e
}

func (t errMetadataScanner) Close() error {
	return nil
}

// MetadataScannerStaticColumns generated by genieql
const MetadataScannerStaticColumns = `library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."updated_at"`

// NewMetadataScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewMetadataScannerStatic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerStatic{
		Rows: rows,
	}
}

// metadataScannerStatic generated by genieql
type metadataScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t metadataScannerStatic) Scan(i *Metadata) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullTime
		c2 sql.NullString
		c3 sql.NullTime
		c4 sql.NullString
		c5 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5); err != nil {
		return err
	}

	if c0.Valid {
		tmp := uint64(c0.Int64)
		i.Bytes = tmp
	}

	if c1.Valid {
		tmp := c1.Time
		i.CreatedAt = tmp
	}

	if c2.Valid {
		tmp := string(c2.String)
		i.Description = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.HiddenAt = tmp
	}

	if c4.Valid {
		if uid, err := uuid.FromBytes([]byte(c4.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c5.Valid {
		tmp := c5.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewMetadataScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewMetadataScannerStaticRow(row *sql.Row) MetadataScannerStaticRow {
	return MetadataScannerStaticRow{
		row: row,
	}
}

// MetadataScannerStaticRow generated by genieql
type MetadataScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t MetadataScannerStaticRow) Scan(i *Metadata) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullTime
		c2 sql.NullString
		c3 sql.NullTime
		c4 sql.NullString
		c5 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5); err != nil {
		return err
	}

	if c0.Valid {
		tmp := uint64(c0.Int64)
		i.Bytes = tmp
	}

	if c1.Valid {
		tmp := c1.Time
		i.CreatedAt = tmp
	}

	if c2.Valid {
		tmp := string(c2.String)
		i.Description = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.HiddenAt = tmp
	}

	if c4.Valid {
		if uid, err := uuid.FromBytes([]byte(c4.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c5.Valid {
		tmp := c5.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t MetadataScannerStaticRow) Err(err error) MetadataScannerStaticRow {
	t.err = err
	return t
}

// NewMetadataScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewMetadataScannerDynamic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerDynamic{
		Rows: rows,
	}
}

// metadataScannerDynamic generated by genieql
type metadataScannerDynamic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t metadataScannerDynamic) Scan(i *Metadata) error {
	const (
		cn0 = "bytes"
		cn1 = "created_at"
		cn2 = "description"
		cn3 = "hidden_at"
		cn4 = "id"
		cn5 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullInt64
		c1      sql.NullTime
		c2      sql.NullString
		c3      sql.NullTime
		c4      sql.NullString
		c5      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := uint64(c0.Int64)
				i.Bytes = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := c1.Time
				i.CreatedAt = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := string(c2.String)
				i.Description = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := c3.Time
				i.HiddenAt = tmp
			}

		case cn4:
			if c4.Valid {
				if uid, err := uuid.FromBytes([]byte(c4.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn5:
			if c5.Valid {
				tmp := c5.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// MetadataInsertWithDefaultsStaticColumns generated by genieql
const MetadataInsertWithDefaultsStaticColumns = `$1,DEFAULT,$2,DEFAULT,$3,DEFAULT`

// MetadataInsertWithDefaultsExplode generated by genieql
func MetadataInsertWithDefaultsExplode(a *Metadata) ([]interface{}, error) {
	var (
		c0 sql.NullInt64  // bytes
		c1 sql.NullString // description
		c2 sql.NullString // id
	)

	c0.Valid = true
	c0.Int64 = int64(a.Bytes)

	c1.Valid = true
	c1.String = a.Description

	c2.Valid = true
	c2.String = a.ID

	return []interface{}{c0, c1, c2}, nil
}

// MetadataInsertWithDefaults generated by genieql
func MetadataInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Metadata) MetadataScannerStaticRow {
	const query = `INSERT INTO "library_metadata" ("bytes","created_at","description","hidden_at","id","updated_at") VALUES ($1,DEFAULT,$2,DEFAULT,$3,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT RETURNING "bytes","created_at","description","hidden_at","id","updated_at"`
	var (
		c0 sql.NullInt64  // bytes
		c1 sql.NullString // description
		c2 sql.NullString
	)
	c0.Valid = true
	c0.Int64 = int64(a.Bytes)
	c1.Valid = true
	c1.String = a.Description
	c2.Valid = true
	c2.String = a.ID // id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2))
}

// MetadataDeleteByID generated by genieql
func MetadataDeleteByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `DELETE FROM library_metadata WHERE "id" = $1 RETURNING library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataTombstoneByID generated by genieql
func MetadataTombstoneByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET tombstoned_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataHideByID generated by genieql
func MetadataHideByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET hidden_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataFindByID generated by genieql
func MetadataFindByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `SELECT library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."hidden_at",library_metadata."id",library_metadata."updated_at" FROM library_metadata WHERE "id" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}


