//go:build !genieql.ignore
// +build !genieql.ignore

package library

import (
	"context"
	"database/sql"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/retrovibed/retrovibed/internal/sqlx"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql auto -v -o genieql.gen.go
// invoked by go generate @ library/10_generate.genieql.go line 3

// Metadata generated by genieql
type Metadata struct {
	ArchiveID       string    `json:"archive_id"`
	AutoDescription string    `json:"auto_description"`
	Bytes           uint64    `json:"bytes"`
	CreatedAt       time.Time `json:"created_at"`
	Description     string    `json:"description"`
	DiskOffset      uint64    `json:"disk_offset"`
	DiskUsage       uint64    `json:"disk_usage"`
	EncryptionSeed  string    `json:"encryption_seed"`
	HiddenAt        time.Time `json:"hidden_at"`
	ID              string    `json:"id"`
	Image           string    `json:"image"`
	KnownMediaID    string    `json:"known_media_id"`
	Mimetype        string    `json:"mimetype"`
	TombstonedAt    time.Time `json:"tombstoned_at"`
	TorrentID       string    `json:"torrent_id"`
	UpdatedAt       time.Time `json:"updated_at"`
}

// Known generated by genieql
type Known struct {
	Adult               bool    `json:"adult"`
	BackdropPath        string  `json:"backdrop_path"`
	Budget              int64   `json:"budget"`
	Duplicates          int64   `json:"duplicates"`
	Genres              string  `json:"genres"`
	Homepage            string  `json:"homepage"`
	ID                  int64   `json:"id"`
	ImdbID              string  `json:"imdb_id"`
	Keywords            string  `json:"keywords"`
	Md5                 string  `json:"md_5"`
	Md5Lower            uint64  `json:"md_5_lower"`
	OriginalLanguage    string  `json:"original_language"`
	OriginalTitle       string  `json:"original_title"`
	Overview            string  `json:"overview"`
	Popularity          float64 `json:"popularity"`
	PosterPath          string  `json:"poster_path"`
	ProductionCompanies string  `json:"production_companies"`
	ProductionCountries string  `json:"production_countries"`
	Revenue             int64   `json:"revenue"`
	Runtime             int64   `json:"runtime"`
	SpokenLanguages     string  `json:"spoken_languages"`
	Status              string  `json:"status"`
	Tagline             string  `json:"tagline"`
	Title               string  `json:"title"`
	UID                 string  `json:"uid"`
	VoteAverage         float64 `json:"vote_average"`
	VoteCount           int64   `json:"vote_count"`
}

// MetadataScanner scanner interface.
type MetadataScanner interface {
	Scan(i *Metadata) error
	Next() bool
	Close() error
	Err() error
}

type errMetadataScanner struct {
	e error
}

func (t errMetadataScanner) Scan(i *Metadata) error {
	return t.e
}

func (t errMetadataScanner) Next() bool {
	return false
}

func (t errMetadataScanner) Err() error {
	return t.e
}

func (t errMetadataScanner) Close() error {
	return nil
}

// MetadataScannerStaticColumns generated by genieql
const MetadataScannerStaticColumns = `library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`

// NewMetadataScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewMetadataScannerStatic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerStatic{
		Rows: rows,
	}
}

// metadataScannerStatic generated by genieql
type metadataScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t metadataScannerStatic) Scan(i *Metadata) error {
	var (
		c0  sql.NullString
		c1  sql.NullString
		c2  sql.Null[uint64]
		c3  sql.NullTime
		c4  sql.NullString
		c5  sql.Null[uint64]
		c6  sql.Null[uint64]
		c7  sql.NullString
		c8  sql.NullTime
		c9  sql.NullString
		c10 sql.NullString
		c11 sql.NullString
		c12 sql.NullString
		c13 sql.NullTime
		c14 sql.NullString
		c15 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15); err != nil {
		return err
	}

	if c0.Valid {
		if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
			return err
		} else {
			i.ArchiveID = uid.String()
		}
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		tmp := c2.V
		i.Bytes = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.CreatedAt = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Description = tmp
	}

	if c5.Valid {
		tmp := c5.V
		i.DiskOffset = tmp
	}

	if c6.Valid {
		tmp := c6.V
		i.DiskUsage = tmp
	}

	if c7.Valid {
		if uid, err := uuid.FromBytes([]byte(c7.String)); err != nil {
			return err
		} else {
			i.EncryptionSeed = uid.String()
		}
	}

	if c8.Valid {
		tmp := c8.Time
		i.HiddenAt = tmp
	}

	if c9.Valid {
		if uid, err := uuid.FromBytes([]byte(c9.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c10.Valid {
		tmp := string(c10.String)
		i.Image = tmp
	}

	if c11.Valid {
		if uid, err := uuid.FromBytes([]byte(c11.String)); err != nil {
			return err
		} else {
			i.KnownMediaID = uid.String()
		}
	}

	if c12.Valid {
		tmp := string(c12.String)
		i.Mimetype = tmp
	}

	if c13.Valid {
		tmp := c13.Time
		i.TombstonedAt = tmp
	}

	if c14.Valid {
		if uid, err := uuid.FromBytes([]byte(c14.String)); err != nil {
			return err
		} else {
			i.TorrentID = uid.String()
		}
	}

	if c15.Valid {
		tmp := c15.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewMetadataScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewMetadataScannerStaticRow(row *sql.Row) MetadataScannerStaticRow {
	return MetadataScannerStaticRow{
		row: row,
	}
}

// MetadataScannerStaticRow generated by genieql
type MetadataScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t MetadataScannerStaticRow) Scan(i *Metadata) error {
	var (
		c0  sql.NullString
		c1  sql.NullString
		c2  sql.Null[uint64]
		c3  sql.NullTime
		c4  sql.NullString
		c5  sql.Null[uint64]
		c6  sql.Null[uint64]
		c7  sql.NullString
		c8  sql.NullTime
		c9  sql.NullString
		c10 sql.NullString
		c11 sql.NullString
		c12 sql.NullString
		c13 sql.NullTime
		c14 sql.NullString
		c15 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15); err != nil {
		return err
	}

	if c0.Valid {
		if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
			return err
		} else {
			i.ArchiveID = uid.String()
		}
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.AutoDescription = tmp
	}

	if c2.Valid {
		tmp := c2.V
		i.Bytes = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.CreatedAt = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Description = tmp
	}

	if c5.Valid {
		tmp := c5.V
		i.DiskOffset = tmp
	}

	if c6.Valid {
		tmp := c6.V
		i.DiskUsage = tmp
	}

	if c7.Valid {
		if uid, err := uuid.FromBytes([]byte(c7.String)); err != nil {
			return err
		} else {
			i.EncryptionSeed = uid.String()
		}
	}

	if c8.Valid {
		tmp := c8.Time
		i.HiddenAt = tmp
	}

	if c9.Valid {
		if uid, err := uuid.FromBytes([]byte(c9.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c10.Valid {
		tmp := string(c10.String)
		i.Image = tmp
	}

	if c11.Valid {
		if uid, err := uuid.FromBytes([]byte(c11.String)); err != nil {
			return err
		} else {
			i.KnownMediaID = uid.String()
		}
	}

	if c12.Valid {
		tmp := string(c12.String)
		i.Mimetype = tmp
	}

	if c13.Valid {
		tmp := c13.Time
		i.TombstonedAt = tmp
	}

	if c14.Valid {
		if uid, err := uuid.FromBytes([]byte(c14.String)); err != nil {
			return err
		} else {
			i.TorrentID = uid.String()
		}
	}

	if c15.Valid {
		tmp := c15.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t MetadataScannerStaticRow) Err(err error) MetadataScannerStaticRow {
	t.err = err
	return t
}

// NewMetadataScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewMetadataScannerDynamic(rows *sql.Rows, err error) MetadataScanner {
	if err != nil {
		return errMetadataScanner{e: err}
	}

	return metadataScannerDynamic{
		Rows: rows,
	}
}

// metadataScannerDynamic generated by genieql
type metadataScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t metadataScannerDynamic) Scan(i *Metadata) error {
	const (
		cn0  = "archive_id"
		cn1  = "auto_description"
		cn2  = "bytes"
		cn3  = "created_at"
		cn4  = "description"
		cn5  = "disk_offset"
		cn6  = "disk_usage"
		cn7  = "encryption_seed"
		cn8  = "hidden_at"
		cn9  = "id"
		cn10 = "image"
		cn11 = "known_media_id"
		cn12 = "mimetype"
		cn13 = "tombstoned_at"
		cn14 = "torrent_id"
		cn15 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullString
		c1      sql.NullString
		c2      sql.Null[uint64]
		c3      sql.NullTime
		c4      sql.NullString
		c5      sql.Null[uint64]
		c6      sql.Null[uint64]
		c7      sql.NullString
		c8      sql.NullTime
		c9      sql.NullString
		c10     sql.NullString
		c11     sql.NullString
		c12     sql.NullString
		c13     sql.NullTime
		c14     sql.NullString
		c15     sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		case cn8:
			dst = append(dst, &c8)
		case cn9:
			dst = append(dst, &c9)
		case cn10:
			dst = append(dst, &c10)
		case cn11:
			dst = append(dst, &c11)
		case cn12:
			dst = append(dst, &c12)
		case cn13:
			dst = append(dst, &c13)
		case cn14:
			dst = append(dst, &c14)
		case cn15:
			dst = append(dst, &c15)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				if uid, err := uuid.FromBytes([]byte(c0.String)); err != nil {
					return err
				} else {
					i.ArchiveID = uid.String()
				}
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.AutoDescription = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := c2.V
				i.Bytes = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := c3.Time
				i.CreatedAt = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := string(c4.String)
				i.Description = tmp
			}

		case cn5:
			if c5.Valid {
				tmp := c5.V
				i.DiskOffset = tmp
			}

		case cn6:
			if c6.Valid {
				tmp := c6.V
				i.DiskUsage = tmp
			}

		case cn7:
			if c7.Valid {
				if uid, err := uuid.FromBytes([]byte(c7.String)); err != nil {
					return err
				} else {
					i.EncryptionSeed = uid.String()
				}
			}

		case cn8:
			if c8.Valid {
				tmp := c8.Time
				i.HiddenAt = tmp
			}

		case cn9:
			if c9.Valid {
				if uid, err := uuid.FromBytes([]byte(c9.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn10:
			if c10.Valid {
				tmp := string(c10.String)
				i.Image = tmp
			}

		case cn11:
			if c11.Valid {
				if uid, err := uuid.FromBytes([]byte(c11.String)); err != nil {
					return err
				} else {
					i.KnownMediaID = uid.String()
				}
			}

		case cn12:
			if c12.Valid {
				tmp := string(c12.String)
				i.Mimetype = tmp
			}

		case cn13:
			if c13.Valid {
				tmp := c13.Time
				i.TombstonedAt = tmp
			}

		case cn14:
			if c14.Valid {
				if uid, err := uuid.FromBytes([]byte(c14.String)); err != nil {
					return err
				} else {
					i.TorrentID = uid.String()
				}
			}

		case cn15:
			if c15.Valid {
				tmp := c15.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t metadataScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t metadataScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t metadataScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// ScoredScanner scanner interface.
type ScoredScanner interface {
	Scan(relevance *float64) error
	Next() bool
	Close() error
	Err() error
}

type errScoredScanner struct {
	e error
}

func (t errScoredScanner) Scan(relevance *float64) error {
	return t.e
}

func (t errScoredScanner) Next() bool {
	return false
}

func (t errScoredScanner) Err() error {
	return t.e
}

func (t errScoredScanner) Close() error {
	return nil
}

// ScoredScannerStaticColumns generated by genieql
const ScoredScannerStaticColumns = ``

// NewScoredScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewScoredScannerStatic(rows *sql.Rows, err error) ScoredScanner {
	if err != nil {
		return errScoredScanner{e: err}
	}

	return scoredScannerStatic{
		Rows: rows,
	}
}

// scoredScannerStatic generated by genieql
type scoredScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t scoredScannerStatic) Scan(relevance *float64) error {
	var (
		c0 sql.NullFloat64
	)

	if err := t.Rows.Scan(&c0); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Float64
		*relevance = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t scoredScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t scoredScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t scoredScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewScoredScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewScoredScannerStaticRow(row *sql.Row) ScoredScannerStaticRow {
	return ScoredScannerStaticRow{
		row: row,
	}
}

// ScoredScannerStaticRow generated by genieql
type ScoredScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t ScoredScannerStaticRow) Scan(relevance *float64) error {
	var (
		c0 sql.NullFloat64
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Float64
		*relevance = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t ScoredScannerStaticRow) Err(err error) ScoredScannerStaticRow {
	t.err = err
	return t
}

// NewScoredScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewScoredScannerDynamic(rows *sql.Rows, err error) ScoredScanner {
	if err != nil {
		return errScoredScanner{e: err}
	}

	return scoredScannerDynamic{
		Rows: rows,
	}
}

// scoredScannerDynamic generated by genieql
type scoredScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t scoredScannerDynamic) Scan(relevance *float64) error {
	const (
		cn0 = "relevance"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullFloat64
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Float64
				*relevance = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t scoredScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t scoredScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t scoredScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// KnownScanner scanner interface.
type KnownScanner interface {
	Scan(i *Known) error
	Next() bool
	Close() error
	Err() error
}

type errKnownScanner struct {
	e error
}

func (t errKnownScanner) Scan(i *Known) error {
	return t.e
}

func (t errKnownScanner) Next() bool {
	return false
}

func (t errKnownScanner) Err() error {
	return t.e
}

func (t errKnownScanner) Close() error {
	return nil
}

// KnownScannerStaticColumns generated by genieql
const KnownScannerStaticColumns = `library_known_media."adult",library_known_media."backdrop_path",library_known_media."budget",library_known_media."duplicates",library_known_media."genres",library_known_media."homepage",library_known_media."id",library_known_media."imdb_id",library_known_media."keywords",library_known_media."md5",library_known_media."md5_lower",library_known_media."original_language",library_known_media."original_title",library_known_media."overview",library_known_media."popularity",library_known_media."poster_path",library_known_media."production_companies",library_known_media."production_countries",library_known_media."revenue",library_known_media."runtime",library_known_media."spoken_languages",library_known_media."status",library_known_media."tagline",library_known_media."title",library_known_media."uid",library_known_media."vote_average",library_known_media."vote_count"`

// NewKnownScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewKnownScannerStatic(rows *sql.Rows, err error) KnownScanner {
	if err != nil {
		return errKnownScanner{e: err}
	}

	return knownScannerStatic{
		Rows: rows,
	}
}

// knownScannerStatic generated by genieql
type knownScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t knownScannerStatic) Scan(i *Known) error {
	var (
		c0  sql.NullBool
		c1  sql.NullString
		c2  sql.NullInt64
		c3  sql.NullInt64
		c4  sql.NullString
		c5  sql.NullString
		c6  sql.NullInt64
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullString
		c10 sql.Null[uint64]
		c11 sql.NullString
		c12 sql.NullString
		c13 sql.NullString
		c14 sql.NullFloat64
		c15 sql.NullString
		c16 sql.NullString
		c17 sql.NullString
		c18 sql.NullInt64
		c19 sql.NullInt64
		c20 sql.NullString
		c21 sql.NullString
		c22 sql.NullString
		c23 sql.NullString
		c24 sql.NullString
		c25 sql.NullFloat64
		c26 sql.NullInt64
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25, &c26); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Bool
		i.Adult = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.BackdropPath = tmp
	}

	if c2.Valid {
		tmp := int64(c2.Int64)
		i.Budget = tmp
	}

	if c3.Valid {
		tmp := int64(c3.Int64)
		i.Duplicates = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Genres = tmp
	}

	if c5.Valid {
		tmp := string(c5.String)
		i.Homepage = tmp
	}

	if c6.Valid {
		tmp := int64(c6.Int64)
		i.ID = tmp
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.ImdbID = tmp
	}

	if c8.Valid {
		tmp := string(c8.String)
		i.Keywords = tmp
	}

	if c9.Valid {
		if uid, err := uuid.FromBytes([]byte(c9.String)); err != nil {
			return err
		} else {
			i.Md5 = uid.String()
		}
	}

	if c10.Valid {
		tmp := c10.V
		i.Md5Lower = tmp
	}

	if c11.Valid {
		tmp := string(c11.String)
		i.OriginalLanguage = tmp
	}

	if c12.Valid {
		tmp := string(c12.String)
		i.OriginalTitle = tmp
	}

	if c13.Valid {
		tmp := string(c13.String)
		i.Overview = tmp
	}

	if c14.Valid {
		tmp := float64(c14.Float64)
		i.Popularity = tmp
	}

	if c15.Valid {
		tmp := string(c15.String)
		i.PosterPath = tmp
	}

	if c16.Valid {
		tmp := string(c16.String)
		i.ProductionCompanies = tmp
	}

	if c17.Valid {
		tmp := string(c17.String)
		i.ProductionCountries = tmp
	}

	if c18.Valid {
		tmp := int64(c18.Int64)
		i.Revenue = tmp
	}

	if c19.Valid {
		tmp := int64(c19.Int64)
		i.Runtime = tmp
	}

	if c20.Valid {
		tmp := string(c20.String)
		i.SpokenLanguages = tmp
	}

	if c21.Valid {
		tmp := string(c21.String)
		i.Status = tmp
	}

	if c22.Valid {
		tmp := string(c22.String)
		i.Tagline = tmp
	}

	if c23.Valid {
		tmp := string(c23.String)
		i.Title = tmp
	}

	if c24.Valid {
		if uid, err := uuid.FromBytes([]byte(c24.String)); err != nil {
			return err
		} else {
			i.UID = uid.String()
		}
	}

	if c25.Valid {
		tmp := float64(c25.Float64)
		i.VoteAverage = tmp
	}

	if c26.Valid {
		tmp := int64(c26.Int64)
		i.VoteCount = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t knownScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t knownScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t knownScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewKnownScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewKnownScannerStaticRow(row *sql.Row) KnownScannerStaticRow {
	return KnownScannerStaticRow{
		row: row,
	}
}

// KnownScannerStaticRow generated by genieql
type KnownScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t KnownScannerStaticRow) Scan(i *Known) error {
	var (
		c0  sql.NullBool
		c1  sql.NullString
		c2  sql.NullInt64
		c3  sql.NullInt64
		c4  sql.NullString
		c5  sql.NullString
		c6  sql.NullInt64
		c7  sql.NullString
		c8  sql.NullString
		c9  sql.NullString
		c10 sql.Null[uint64]
		c11 sql.NullString
		c12 sql.NullString
		c13 sql.NullString
		c14 sql.NullFloat64
		c15 sql.NullString
		c16 sql.NullString
		c17 sql.NullString
		c18 sql.NullInt64
		c19 sql.NullInt64
		c20 sql.NullString
		c21 sql.NullString
		c22 sql.NullString
		c23 sql.NullString
		c24 sql.NullString
		c25 sql.NullFloat64
		c26 sql.NullInt64
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25, &c26); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Bool
		i.Adult = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.BackdropPath = tmp
	}

	if c2.Valid {
		tmp := int64(c2.Int64)
		i.Budget = tmp
	}

	if c3.Valid {
		tmp := int64(c3.Int64)
		i.Duplicates = tmp
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.Genres = tmp
	}

	if c5.Valid {
		tmp := string(c5.String)
		i.Homepage = tmp
	}

	if c6.Valid {
		tmp := int64(c6.Int64)
		i.ID = tmp
	}

	if c7.Valid {
		tmp := string(c7.String)
		i.ImdbID = tmp
	}

	if c8.Valid {
		tmp := string(c8.String)
		i.Keywords = tmp
	}

	if c9.Valid {
		if uid, err := uuid.FromBytes([]byte(c9.String)); err != nil {
			return err
		} else {
			i.Md5 = uid.String()
		}
	}

	if c10.Valid {
		tmp := c10.V
		i.Md5Lower = tmp
	}

	if c11.Valid {
		tmp := string(c11.String)
		i.OriginalLanguage = tmp
	}

	if c12.Valid {
		tmp := string(c12.String)
		i.OriginalTitle = tmp
	}

	if c13.Valid {
		tmp := string(c13.String)
		i.Overview = tmp
	}

	if c14.Valid {
		tmp := float64(c14.Float64)
		i.Popularity = tmp
	}

	if c15.Valid {
		tmp := string(c15.String)
		i.PosterPath = tmp
	}

	if c16.Valid {
		tmp := string(c16.String)
		i.ProductionCompanies = tmp
	}

	if c17.Valid {
		tmp := string(c17.String)
		i.ProductionCountries = tmp
	}

	if c18.Valid {
		tmp := int64(c18.Int64)
		i.Revenue = tmp
	}

	if c19.Valid {
		tmp := int64(c19.Int64)
		i.Runtime = tmp
	}

	if c20.Valid {
		tmp := string(c20.String)
		i.SpokenLanguages = tmp
	}

	if c21.Valid {
		tmp := string(c21.String)
		i.Status = tmp
	}

	if c22.Valid {
		tmp := string(c22.String)
		i.Tagline = tmp
	}

	if c23.Valid {
		tmp := string(c23.String)
		i.Title = tmp
	}

	if c24.Valid {
		if uid, err := uuid.FromBytes([]byte(c24.String)); err != nil {
			return err
		} else {
			i.UID = uid.String()
		}
	}

	if c25.Valid {
		tmp := float64(c25.Float64)
		i.VoteAverage = tmp
	}

	if c26.Valid {
		tmp := int64(c26.Int64)
		i.VoteCount = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t KnownScannerStaticRow) Err(err error) KnownScannerStaticRow {
	t.err = err
	return t
}

// NewKnownScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewKnownScannerDynamic(rows *sql.Rows, err error) KnownScanner {
	if err != nil {
		return errKnownScanner{e: err}
	}

	return knownScannerDynamic{
		Rows: rows,
	}
}

// knownScannerDynamic generated by genieql
type knownScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t knownScannerDynamic) Scan(i *Known) error {
	const (
		cn0  = "adult"
		cn1  = "backdrop_path"
		cn2  = "budget"
		cn3  = "duplicates"
		cn4  = "genres"
		cn5  = "homepage"
		cn6  = "id"
		cn7  = "imdb_id"
		cn8  = "keywords"
		cn9  = "md5"
		cn10 = "md5_lower"
		cn11 = "original_language"
		cn12 = "original_title"
		cn13 = "overview"
		cn14 = "popularity"
		cn15 = "poster_path"
		cn16 = "production_companies"
		cn17 = "production_countries"
		cn18 = "revenue"
		cn19 = "runtime"
		cn20 = "spoken_languages"
		cn21 = "status"
		cn22 = "tagline"
		cn23 = "title"
		cn24 = "uid"
		cn25 = "vote_average"
		cn26 = "vote_count"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullBool
		c1      sql.NullString
		c2      sql.NullInt64
		c3      sql.NullInt64
		c4      sql.NullString
		c5      sql.NullString
		c6      sql.NullInt64
		c7      sql.NullString
		c8      sql.NullString
		c9      sql.NullString
		c10     sql.Null[uint64]
		c11     sql.NullString
		c12     sql.NullString
		c13     sql.NullString
		c14     sql.NullFloat64
		c15     sql.NullString
		c16     sql.NullString
		c17     sql.NullString
		c18     sql.NullInt64
		c19     sql.NullInt64
		c20     sql.NullString
		c21     sql.NullString
		c22     sql.NullString
		c23     sql.NullString
		c24     sql.NullString
		c25     sql.NullFloat64
		c26     sql.NullInt64
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		case cn8:
			dst = append(dst, &c8)
		case cn9:
			dst = append(dst, &c9)
		case cn10:
			dst = append(dst, &c10)
		case cn11:
			dst = append(dst, &c11)
		case cn12:
			dst = append(dst, &c12)
		case cn13:
			dst = append(dst, &c13)
		case cn14:
			dst = append(dst, &c14)
		case cn15:
			dst = append(dst, &c15)
		case cn16:
			dst = append(dst, &c16)
		case cn17:
			dst = append(dst, &c17)
		case cn18:
			dst = append(dst, &c18)
		case cn19:
			dst = append(dst, &c19)
		case cn20:
			dst = append(dst, &c20)
		case cn21:
			dst = append(dst, &c21)
		case cn22:
			dst = append(dst, &c22)
		case cn23:
			dst = append(dst, &c23)
		case cn24:
			dst = append(dst, &c24)
		case cn25:
			dst = append(dst, &c25)
		case cn26:
			dst = append(dst, &c26)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Bool
				i.Adult = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.BackdropPath = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := int64(c2.Int64)
				i.Budget = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := int64(c3.Int64)
				i.Duplicates = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := string(c4.String)
				i.Genres = tmp
			}

		case cn5:
			if c5.Valid {
				tmp := string(c5.String)
				i.Homepage = tmp
			}

		case cn6:
			if c6.Valid {
				tmp := int64(c6.Int64)
				i.ID = tmp
			}

		case cn7:
			if c7.Valid {
				tmp := string(c7.String)
				i.ImdbID = tmp
			}

		case cn8:
			if c8.Valid {
				tmp := string(c8.String)
				i.Keywords = tmp
			}

		case cn9:
			if c9.Valid {
				if uid, err := uuid.FromBytes([]byte(c9.String)); err != nil {
					return err
				} else {
					i.Md5 = uid.String()
				}
			}

		case cn10:
			if c10.Valid {
				tmp := c10.V
				i.Md5Lower = tmp
			}

		case cn11:
			if c11.Valid {
				tmp := string(c11.String)
				i.OriginalLanguage = tmp
			}

		case cn12:
			if c12.Valid {
				tmp := string(c12.String)
				i.OriginalTitle = tmp
			}

		case cn13:
			if c13.Valid {
				tmp := string(c13.String)
				i.Overview = tmp
			}

		case cn14:
			if c14.Valid {
				tmp := float64(c14.Float64)
				i.Popularity = tmp
			}

		case cn15:
			if c15.Valid {
				tmp := string(c15.String)
				i.PosterPath = tmp
			}

		case cn16:
			if c16.Valid {
				tmp := string(c16.String)
				i.ProductionCompanies = tmp
			}

		case cn17:
			if c17.Valid {
				tmp := string(c17.String)
				i.ProductionCountries = tmp
			}

		case cn18:
			if c18.Valid {
				tmp := int64(c18.Int64)
				i.Revenue = tmp
			}

		case cn19:
			if c19.Valid {
				tmp := int64(c19.Int64)
				i.Runtime = tmp
			}

		case cn20:
			if c20.Valid {
				tmp := string(c20.String)
				i.SpokenLanguages = tmp
			}

		case cn21:
			if c21.Valid {
				tmp := string(c21.String)
				i.Status = tmp
			}

		case cn22:
			if c22.Valid {
				tmp := string(c22.String)
				i.Tagline = tmp
			}

		case cn23:
			if c23.Valid {
				tmp := string(c23.String)
				i.Title = tmp
			}

		case cn24:
			if c24.Valid {
				if uid, err := uuid.FromBytes([]byte(c24.String)); err != nil {
					return err
				} else {
					i.UID = uid.String()
				}
			}

		case cn25:
			if c25.Valid {
				tmp := float64(c25.Float64)
				i.VoteAverage = tmp
			}

		case cn26:
			if c26.Valid {
				tmp := int64(c26.Int64)
				i.VoteCount = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t knownScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t knownScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t knownScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// MetadataInsertWithDefaultsStaticColumns generated by genieql
const MetadataInsertWithDefaultsStaticColumns = `$1,$2,$3,DEFAULT,$4,$5,$6,$7,DEFAULT,$8,$9,$10,$11,DEFAULT,$12,DEFAULT`

// MetadataInsertWithDefaultsExplode generated by genieql
func MetadataInsertWithDefaultsExplode(a *Metadata) ([]interface{}, error) {
	var (
		c0  sql.NullString   // archive_id
		c1  sql.NullString   // auto_description
		c2  sql.Null[uint64] // bytes
		c3  sql.NullString   // description
		c4  sql.Null[uint64] // disk_offset
		c5  sql.Null[uint64] // disk_usage
		c6  sql.NullString   // encryption_seed
		c7  sql.NullString   // id
		c8  sql.NullString   // image
		c9  sql.NullString   // known_media_id
		c10 sql.NullString   // mimetype
		c11 sql.NullString   // torrent_id
	)

	c0.Valid = true
	c0.String = a.ArchiveID

	c1.Valid = true
	c1.String = a.AutoDescription

	c2.Valid = true
	c2.V = a.Bytes

	c3.Valid = true
	c3.String = a.Description

	c4.Valid = true
	c4.V = a.DiskOffset

	c5.Valid = true
	c5.V = a.DiskUsage

	c6.Valid = true
	c6.String = a.EncryptionSeed

	c7.Valid = true
	c7.String = a.ID

	c8.Valid = true
	c8.String = a.Image

	c9.Valid = true
	c9.String = a.KnownMediaID

	c10.Valid = true
	c10.String = a.Mimetype

	c11.Valid = true
	c11.String = a.TorrentID

	return []interface{}{c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11}, nil
}

// MetadataInsertWithDefaults generated by genieql
func MetadataInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Metadata) MetadataScannerStaticRow {
	const query = `INSERT INTO "library_metadata" ("archive_id","auto_description","bytes","created_at","description","disk_offset","disk_usage","encryption_seed","hidden_at","id","image","known_media_id","mimetype","tombstoned_at","torrent_id","updated_at") VALUES ($1,$2,$3,DEFAULT,$4,$5,$6,$7,DEFAULT,$8,$9,$10,$11,DEFAULT,$12,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT, archive_id = EXCLUDED.archive_id RETURNING "archive_id","auto_description","bytes","created_at","description","disk_offset","disk_usage","encryption_seed","hidden_at","id","image","known_media_id","mimetype","tombstoned_at","torrent_id","updated_at"`
	var (
		c0  sql.NullString   // archive_id
		c1  sql.NullString   // auto_description
		c2  sql.Null[uint64] // bytes
		c3  sql.NullString   // description
		c4  sql.Null[uint64] // disk_offset
		c5  sql.Null[uint64] // disk_usage
		c6  sql.NullString   // encryption_seed
		c7  sql.NullString   // id
		c8  sql.NullString   // image
		c9  sql.NullString   // known_media_id
		c10 sql.NullString   // mimetype
		c11 sql.NullString
	)
	c0.Valid = true
	c0.String = a.ArchiveID
	c1.Valid = true
	c1.String = a.AutoDescription
	c2.Valid = true
	c2.V = a.Bytes
	c3.Valid = true
	c3.String = a.Description
	c4.Valid = true
	c4.V = a.DiskOffset
	c5.Valid = true
	c5.V = a.DiskUsage
	c6.Valid = true
	c6.String = a.EncryptionSeed
	c7.Valid = true
	c7.String = a.ID
	c8.Valid = true
	c8.String = a.Image
	c9.Valid = true
	c9.String = a.KnownMediaID
	c10.Valid = true
	c10.String = a.Mimetype
	c11.Valid = true
	c11.String = a.TorrentID // torrent_id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11))
}

// MetadataDeleteByID generated by genieql
func MetadataDeleteByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `DELETE FROM library_metadata WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataTombstoneByID generated by genieql
func MetadataTombstoneByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET tombstoned_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataArchivedByID generated by genieql
func MetadataArchivedByID(ctx context.Context, q sqlx.Queryer, id, aid string, quota uint64) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET archive_id = $2, quota_usage = $3 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // aid
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = aid
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, quota))
}

// MetadataHideByID generated by genieql
func MetadataHideByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET hidden_at = NOW(), initiated_at = 'infinity' WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataUpdateAutodescriptionByID generated by genieql
func MetadataUpdateAutodescriptionByID(ctx context.Context, q sqlx.Queryer, id string, autodescription string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET updated_at = NOW(), auto_description = $2 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // autodescription
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = autodescription
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// MetadataUpdateDescriptionByID generated by genieql
func MetadataUpdateDescriptionByID(ctx context.Context, q sqlx.Queryer, id string, description string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET updated_at = NOW(), description = $2 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // description
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = description
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// MetadataFindByID generated by genieql
func MetadataFindByID(ctx context.Context, q sqlx.Queryer, id string) MetadataScannerStaticRow {
	const query = `SELECT library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at" FROM library_metadata WHERE "id" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataFindByDescription generated by genieql
func MetadataFindByDescription(ctx context.Context, q sqlx.Queryer, desc string) MetadataScannerStaticRow {
	const query = `SELECT library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at" FROM library_metadata WHERE "description" = $1`
	var c0 sql.NullString // desc
	c0.Valid = true
	c0.String = desc
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// MetadataAssociateTorrent generated by genieql
func MetadataAssociateTorrent(ctx context.Context, q sqlx.Queryer, desc, tid string) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET torrent_id = $2 WHERE "description" = $1 AND torrent_id = '00000000-0000-0000-0000-000000000000' RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // desc
		c1 sql.NullString // tid
	)
	c0.Valid = true
	c0.String = desc
	c1.Valid = true
	c1.String = tid
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// MetadataUpdate generated by genieql
func MetadataUpdate(ctx context.Context, q sqlx.Queryer, id string, md Metadata) MetadataScannerStaticRow {
	const query = `UPDATE library_metadata SET description = $2, known_media_id = $3 WHERE "id" = $1 RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // description
		c2 sql.NullString // known_media_id
	)
	c0.Valid = true
	c0.String = id
	c1.Valid = true
	c1.String = md.Description
	c2.Valid = true
	c2.String = md.KnownMediaID
	return NewMetadataScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2))
}

// MetadataTransferKnownMediaIDFromTorrent generated by genieql
func MetadataTransferKnownMediaIDFromTorrent(ctx context.Context, q sqlx.Queryer, ts time.Time) MetadataScanner {
	const query = `UPDATE library_metadata SET updated_at = NOW(), known_media_id = t.known_media_id FROM torrents_metadata AS t WHERE t.id = library_metadata.torrent_id AND t."updated_at" >= $1 AND library_metadata.known_media_id = 'ffffffff-ffff-ffff-ffff-ffffffffffff' AND t.known_media_id NOT IN ('ffffffff-ffff-ffff-ffff-ffffffffffff', '00000000-0000-0000-0000-000000000000') RETURNING library_metadata."archive_id",library_metadata."auto_description",library_metadata."bytes",library_metadata."created_at",library_metadata."description",library_metadata."disk_offset",library_metadata."disk_usage",library_metadata."encryption_seed",library_metadata."hidden_at",library_metadata."id",library_metadata."image",library_metadata."known_media_id",library_metadata."mimetype",library_metadata."tombstoned_at",library_metadata."torrent_id",library_metadata."updated_at"`
	var c0 sql.NullTime // ts
	c0.Valid = true
	c0.Time = ts
	return NewMetadataScannerStatic(q.QueryContext(ctx, query, c0))
}

// KnownInsertWithDefaultsStaticColumns generated by genieql
const KnownInsertWithDefaultsStaticColumns = `$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27`

// KnownInsertWithDefaultsExplode generated by genieql
func KnownInsertWithDefaultsExplode(a *Known) ([]interface{}, error) {
	var (
		c0  sql.NullBool     // adult
		c1  sql.NullString   // backdrop_path
		c2  sql.NullInt64    // budget
		c3  sql.NullInt64    // duplicates
		c4  sql.NullString   // genres
		c5  sql.NullString   // homepage
		c6  sql.NullInt64    // id
		c7  sql.NullString   // imdb_id
		c8  sql.NullString   // keywords
		c9  sql.NullString   // md5
		c10 sql.Null[uint64] // md5_lower
		c11 sql.NullString   // original_language
		c12 sql.NullString   // original_title
		c13 sql.NullString   // overview
		c14 sql.NullFloat64  // popularity
		c15 sql.NullString   // poster_path
		c16 sql.NullString   // production_companies
		c17 sql.NullString   // production_countries
		c18 sql.NullInt64    // revenue
		c19 sql.NullInt64    // runtime
		c20 sql.NullString   // spoken_languages
		c21 sql.NullString   // status
		c22 sql.NullString   // tagline
		c23 sql.NullString   // title
		c24 sql.NullString   // uid
		c25 sql.NullFloat64  // vote_average
		c26 sql.NullInt64    // vote_count
	)

	c0.Valid = true
	c0.Bool = a.Adult

	c1.Valid = true
	c1.String = a.BackdropPath

	c2.Valid = true
	c2.Int64 = int64(a.Budget)

	c3.Valid = true
	c3.Int64 = int64(a.Duplicates)

	c4.Valid = true
	c4.String = a.Genres

	c5.Valid = true
	c5.String = a.Homepage

	c6.Valid = true
	c6.Int64 = int64(a.ID)

	c7.Valid = true
	c7.String = a.ImdbID

	c8.Valid = true
	c8.String = a.Keywords

	c9.Valid = true
	c9.String = a.Md5

	c10.Valid = true
	c10.V = a.Md5Lower

	c11.Valid = true
	c11.String = a.OriginalLanguage

	c12.Valid = true
	c12.String = a.OriginalTitle

	c13.Valid = true
	c13.String = a.Overview

	c14.Valid = true
	c14.Float64 = float64(a.Popularity)

	c15.Valid = true
	c15.String = a.PosterPath

	c16.Valid = true
	c16.String = a.ProductionCompanies

	c17.Valid = true
	c17.String = a.ProductionCountries

	c18.Valid = true
	c18.Int64 = int64(a.Revenue)

	c19.Valid = true
	c19.Int64 = int64(a.Runtime)

	c20.Valid = true
	c20.String = a.SpokenLanguages

	c21.Valid = true
	c21.String = a.Status

	c22.Valid = true
	c22.String = a.Tagline

	c23.Valid = true
	c23.String = a.Title

	c24.Valid = true
	c24.String = a.UID

	c25.Valid = true
	c25.Float64 = float64(a.VoteAverage)

	c26.Valid = true
	c26.Int64 = int64(a.VoteCount)

	return []interface{}{c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26}, nil
}

// KnownInsertWithDefaults generated by genieql
func KnownInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Known) KnownScannerStaticRow {
	const query = `INSERT INTO "library_known_media" ("adult","backdrop_path","budget","duplicates","genres","homepage","id","imdb_id","keywords","md5","md5_lower","original_language","original_title","overview","popularity","poster_path","production_companies","production_countries","revenue","runtime","spoken_languages","status","tagline","title","uid","vote_average","vote_count") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27) RETURNING "adult","backdrop_path","budget","duplicates","genres","homepage","id","imdb_id","keywords","md5","md5_lower","original_language","original_title","overview","popularity","poster_path","production_companies","production_countries","revenue","runtime","spoken_languages","status","tagline","title","uid","vote_average","vote_count"`
	var (
		c0  sql.NullBool     // adult
		c1  sql.NullString   // backdrop_path
		c2  sql.NullInt64    // budget
		c3  sql.NullInt64    // duplicates
		c4  sql.NullString   // genres
		c5  sql.NullString   // homepage
		c6  sql.NullInt64    // id
		c7  sql.NullString   // imdb_id
		c8  sql.NullString   // keywords
		c9  sql.NullString   // md5
		c10 sql.Null[uint64] // md5_lower
		c11 sql.NullString   // original_language
		c12 sql.NullString   // original_title
		c13 sql.NullString   // overview
		c14 sql.NullFloat64  // popularity
		c15 sql.NullString   // poster_path
		c16 sql.NullString   // production_companies
		c17 sql.NullString   // production_countries
		c18 sql.NullInt64    // revenue
		c19 sql.NullInt64    // runtime
		c20 sql.NullString   // spoken_languages
		c21 sql.NullString   // status
		c22 sql.NullString   // tagline
		c23 sql.NullString   // title
		c24 sql.NullString   // uid
		c25 sql.NullFloat64  // vote_average
		c26 sql.NullInt64
	)
	c0.Valid = true
	c0.Bool = a.Adult
	c1.Valid = true
	c1.String = a.BackdropPath
	c2.Valid = true
	c2.Int64 = int64(a.Budget)
	c3.Valid = true
	c3.Int64 = int64(a.Duplicates)
	c4.Valid = true
	c4.String = a.Genres
	c5.Valid = true
	c5.String = a.Homepage
	c6.Valid = true
	c6.Int64 = int64(a.ID)
	c7.Valid = true
	c7.String = a.ImdbID
	c8.Valid = true
	c8.String = a.Keywords
	c9.Valid = true
	c9.String = a.Md5
	c10.Valid = true
	c10.V = a.Md5Lower
	c11.Valid = true
	c11.String = a.OriginalLanguage
	c12.Valid = true
	c12.String = a.OriginalTitle
	c13.Valid = true
	c13.String = a.Overview
	c14.Valid = true
	c14.Float64 = float64(a.Popularity)
	c15.Valid = true
	c15.String = a.PosterPath
	c16.Valid = true
	c16.String = a.ProductionCompanies
	c17.Valid = true
	c17.String = a.ProductionCountries
	c18.Valid = true
	c18.Int64 = int64(a.Revenue)
	c19.Valid = true
	c19.Int64 = int64(a.Runtime)
	c20.Valid = true
	c20.String = a.SpokenLanguages
	c21.Valid = true
	c21.String = a.Status
	c22.Valid = true
	c22.String = a.Tagline
	c23.Valid = true
	c23.String = a.Title
	c24.Valid = true
	c24.String = a.UID
	c25.Valid = true
	c25.Float64 = float64(a.VoteAverage)
	c26.Valid = true
	c26.Int64 = int64(a.VoteCount) // vote_count
	return NewKnownScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26))
}

// KnownFindByID generated by genieql
func KnownFindByID(ctx context.Context, q sqlx.Queryer, id string) KnownScannerStaticRow {
	const query = `SELECT library_known_media."adult",library_known_media."backdrop_path",library_known_media."budget",library_known_media."duplicates",library_known_media."genres",library_known_media."homepage",library_known_media."id",library_known_media."imdb_id",library_known_media."keywords",library_known_media."md5",library_known_media."md5_lower",library_known_media."original_language",library_known_media."original_title",library_known_media."overview",library_known_media."popularity",library_known_media."poster_path",library_known_media."production_companies",library_known_media."production_countries",library_known_media."revenue",library_known_media."runtime",library_known_media."spoken_languages",library_known_media."status",library_known_media."tagline",library_known_media."title",library_known_media."uid",library_known_media."vote_average",library_known_media."vote_count" FROM library_known_media WHERE "uid" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewKnownScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// KnownScoreByID generated by genieql
func KnownScoreByID(ctx context.Context, q sqlx.Queryer, uid string, terms string) ScoredScannerStaticRow {
	const query = `SELECT COALESCE(fts_main_library_known_media.match_bm25(md5_lower, $2), 0.0)::float AS relevance FROM library_known_media WHERE uid = $1`
	var (
		c0 sql.NullString // uid
		c1 sql.NullString // terms
	)
	c0.Valid = true
	c0.String = uid
	c1.Valid = true
	c1.String = terms
	return NewScoredScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// KnownBestMatch generated by genieql
func KnownBestMatch(ctx context.Context, q sqlx.Queryer, terms string, cutoff float32) KnownScannerStaticRow {
	const query = `WITH scored AS (SELECT uid, $1 as q, (jaro_winkler_similarity(title, q, $2) + jaro_similarity(title, q, $2)) / 2 AS relevance FROM library_known_media WHERE NOT adult ORDER BY relevance DESC) SELECT library_known_media."adult",library_known_media."backdrop_path",library_known_media."budget",library_known_media."duplicates",library_known_media."genres",library_known_media."homepage",library_known_media."id",library_known_media."imdb_id",library_known_media."keywords",library_known_media."md5",library_known_media."md5_lower",library_known_media."original_language",library_known_media."original_title",library_known_media."overview",library_known_media."popularity",library_known_media."poster_path",library_known_media."production_companies",library_known_media."production_countries",library_known_media."revenue",library_known_media."runtime",library_known_media."spoken_languages",library_known_media."status",library_known_media."tagline",library_known_media."title",library_known_media."uid",library_known_media."vote_average",library_known_media."vote_count" FROM library_known_media INNER JOIN scored ON library_known_media.uid = scored.uid WHERE scored.relevance > $2 ORDER BY scored.relevance DESC`
	var (
		c0 sql.NullString  // terms
		c1 sql.NullFloat64 // cutoff
	)
	c0.Valid = true
	c0.String = terms
	c1.Valid = true
	c1.Float64 = float64(cutoff)
	return NewKnownScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}
