package genieql

import (
	"log"
	"net/url"
	"os"
	"path/filepath"
	"runtime/debug"
	"strconv"
	"strings"
	"time"

	"github.com/james-lawrence/genieql/internal/errorsx"
	"github.com/james-lawrence/genieql/internal/stringsx"
	"gopkg.in/yaml.v3"
)

// Configuration main configuration for genieql. usually generated by the Bootstrap
// function.
type Configuration struct {
	Version       string `yaml:"-"`
	Location      string `yaml:"-"`
	Name          string
	Dialect       string
	Driver        string
	Queryer       string
	RowType       string
	ConnectionURL string
	Host          string
	Port          int
	Database      string
	Username      string
	Password      string
}

// ReadMap the column -> struct mapping from disk cache.
func (t Configuration) ReadMap(m *MappingConfig, options ...MappingConfigOption) error {
	m.Apply(options...)
	return ReadMapper(t, "default", m)
}

// WriteMap persists the column -> struct mapping to disk cache.
func (t Configuration) WriteMap(m MappingConfig) error {
	return WriteMapper(t, "default", m)
}

// Bootstrap takes a db connection url and creates a genieql
// configuration from the url and writes out the configuration to the provided
// path.
func Bootstrap(options ...ConfigurationOption) error {
	var (
		err    error
		config Configuration
	)

	if config, err = NewConfiguration(options...); err != nil {
		return err
	}

	if err := os.MkdirAll(config.Location, 0755); err != nil {
		return errorsx.Wrap(err, "failed to make bootstrap directory")
	}

	return WriteConfiguration(config)
}

// WriteConfiguration writes the genieql configuration file to the specified path.
func WriteConfiguration(config Configuration) error {
	var (
		err error
		raw []byte
	)

	if raw, err = yaml.Marshal(config); err != nil {
		return errorsx.Wrap(err, "failed to serialize configuration to yaml")
	}

	return errorsx.Wrap(os.WriteFile(filepath.Join(config.Location, config.Name), raw, 0666), "failed to persist configuration to disk")
}

// ReadConfiguration reads the genieql configuration file from the specified path.
func ReadConfiguration(config *Configuration, options ...ConfigurationOption) error {
	var (
		err error
		raw []byte
	)

	if raw, err = os.ReadFile(filepath.Join(config.Location, config.Name)); err != nil {
		return errorsx.Wrap(err, "failed to read configuration file")
	}

	if err = yaml.Unmarshal(raw, config); err != nil {
		return errorsx.Wrap(err, "failed to parse configuration file")
	}

	if *config, err = config.Clone(options...); err != nil {
		return errorsx.Wrap(err, "failed to apply options to config")
	}
	return nil
}

// MustConfiguration builds a configuration from the provided options.
func MustConfiguration(c Configuration, err error) Configuration {
	if err != nil {
		log.Fatalf("%+v\n", err)
	}

	return c
}

// MustReadConfiguration builds a new configuration from the provided options,
// and read's it from disk.
func MustReadConfiguration(options ...ConfigurationOption) Configuration {
	c := MustConfiguration(NewConfiguration(options...))
	if e := ReadConfiguration(&c); e != nil {
		log.Fatalf("%+v\n", e)
	}
	return c
}

// NewConfiguration builds a configuration from the provided options.
func NewConfiguration(options ...ConfigurationOption) (Configuration, error) {
	var (
		cachebuster string
	)

	cachebuster = time.Now().Truncate(time.Hour).String()
	if info, ok := debug.ReadBuildInfo(); ok {
		cachebuster = stringsx.DefaultIfBlank(info.Main.Version, cachebuster)
	}

	var (
		config = Configuration{
			Version: cachebuster,
			Queryer: "*sql.DB",
			RowType: "*sql.Row",
		}
	)

	return config.Clone(options...)
}

func (t Configuration) Clone(options ...ConfigurationOption) (Configuration, error) {
	for _, opt := range options {
		if err := opt(&t); err != nil {
			return t, err
		}
	}

	return t, nil
}

// ConfigurationOption options for creating a Configuration
type ConfigurationOption func(*Configuration) error

// ConfigurationOptionLocation specify the absolute path of the configuration file.
func ConfigurationOptionLocation(path string) ConfigurationOption {
	return func(c *Configuration) error {
		c.Location, c.Name = filepath.Dir(path), filepath.Base(path)
		return nil
	}
}

// ConfigurationOptionQueryer specify the default queryer to use.
func ConfigurationOptionQueryer(queryer string) ConfigurationOption {
	return func(c *Configuration) error {
		c.Queryer = queryer
		return nil
	}
}

// ConfigurationOptionRowType specify the default type to use for static row scanners.
func ConfigurationOptionRowType(rt string) ConfigurationOption {
	return func(c *Configuration) error {
		c.RowType = rt
		return nil
	}
}

// ConfigurationOptionRowType specify the default type to use for static row scanners.
func ConfigurationOptionZeroDynamic(c *Configuration) error {
	c.Version = ""
	return nil
}

// ConfigurationOptionDatabase specify the database connection information.
func ConfigurationOptionDatabase(uri *url.URL) ConfigurationOption {
	return func(c *Configuration) (err error) {
		var (
			host     string
			sport    string
			port     int
			database string
		)

		splits := strings.Split(uri.Host, ":")
		switch len(splits) {
		case 2:
			host, sport = splits[0], splits[1]
			port, err = strconv.Atoi(sport)
			if err != nil {
				return err
			}
		case 1:
			host = uri.Host
		}

		switch uri.Scheme {
		case "duckdb":
			database = filepath.Join(ConfigurationDirectory(), ".duckdb", uri.Path)
		default:
			database = strings.Trim(uri.Path, "/")
		}

		c.ConnectionURL = uri.String()
		c.Dialect = uri.Scheme
		c.Host = host
		c.Port = port
		c.Database = database
		c.Username = uri.User.Username()
		c.Password, _ = uri.User.Password()
		return nil
	}
}

// ConfigurationOptionDriver specify the driver for the configuration.
func ConfigurationOptionDriver(driver string) ConfigurationOption {
	return func(c *Configuration) error {
		c.Driver = driver
		return nil
	}
}

// ConfigurationOptionDialect specify the dialect
func ConfigurationOptionDialect(d string) ConfigurationOption {
	return func(c *Configuration) error {
		c.Dialect = d
		return nil
	}
}
